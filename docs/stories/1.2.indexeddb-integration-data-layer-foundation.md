# Story 1.2: IndexedDB Integration and Data Layer Foundation

## Status
Draft

## Story
**As a** developer,
**I want** IndexedDB integrated with a data access layer,
**so that** the application can persistently store and retrieve tasks, clients, and projects locally in the browser.

## Acceptance Criteria

1. IndexedDB database schema designed and implemented for tasks, clients, and projects
2. Data access layer created with functions for CRUD operations (create, read, update, delete) for each entity type
3. Database initialization function handles database creation and version migrations
4. Error handling implemented for database operations with user-friendly error messages
5. Database operations are testable via unit tests with mock IndexedDB
6. Data persistence verified: data persists across browser sessions (close and reopen browser)
7. Database can handle at least 1000 tasks without performance degradation
8. All database operations use async/await pattern for proper error handling

## Tasks / Subtasks

- [ ] Task 1: Install and configure Dexie.js (AC: 1, 8)
  - [ ] Install Dexie.js ^3.2.4 as specified in tech stack
  - [ ] Verify Dexie.js version matches architecture requirements
  - [ ] Add Dexie.js types for TypeScript support

- [ ] Task 2: Create database schema definition (AC: 1)
  - [ ] Create `src/services/data/database.ts` file
  - [ ] Define TimeTrackingDB class extending Dexie
  - [ ] Define tables: tasks, clients, projects (initial schema for Story 1.2)
  - [ ] Configure version 1 schema with proper indexes:
    - [ ] tasks: 'id, columnId, clientId, projectId, createdAt, updatedAt, [clientId+projectId]'
    - [ ] clients: 'id, name, createdAt'
    - [ ] projects: 'id, clientId, name, [clientId+name]'
  - [ ] Export database instance
  - [ ] Ensure TypeScript types are properly defined for all tables

- [ ] Task 3: Create TypeScript type definitions (AC: 1)
  - [ ] Create `src/types/task.ts` with Task interface
  - [ ] Create `src/types/client.ts` with Client interface
  - [ ] Create `src/types/project.ts` with Project interface
  - [ ] Ensure types match data models from architecture docs
  - [ ] Export types for use in repositories

- [ ] Task 4: Implement TaskRepository (AC: 2, 8)
  - [ ] Create `src/services/data/repositories/TaskRepository.ts`
  - [ ] Implement `create(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<Task>`
  - [ ] Implement `getById(id: string): Promise<Task | undefined>`
  - [ ] Implement `getAll(): Promise<Task[]>`
  - [ ] Implement `getByColumnId(columnId: string): Promise<Task[]>`
  - [ ] Implement `getByClientId(clientId: string): Promise<Task[]>`
  - [ ] Implement `getByProjectId(projectId: string): Promise<Task[]>`
  - [ ] Implement `update(id: string, updates: Partial<Task>): Promise<Task>`
  - [ ] Implement `delete(id: string): Promise<void>`
  - [ ] Ensure all methods use async/await pattern
  - [ ] Ensure all methods handle errors appropriately
  - [ ] Ensure updatedAt timestamp is automatically set on updates

- [ ] Task 5: Implement ClientRepository (AC: 2, 8)
  - [ ] Create `src/services/data/repositories/ClientRepository.ts`
  - [ ] Implement `create(client: Omit<Client, 'id' | 'createdAt' | 'updatedAt'>): Promise<Client>`
  - [ ] Implement `getById(id: string): Promise<Client | undefined>`
  - [ ] Implement `getAll(): Promise<Client[]>`
  - [ ] Implement `update(id: string, updates: Partial<Client>): Promise<Client>`
  - [ ] Implement `delete(id: string): Promise<void>`
  - [ ] Ensure all methods use async/await pattern
  - [ ] Ensure all methods handle errors appropriately
  - [ ] Ensure updatedAt timestamp is automatically set on updates

- [ ] Task 6: Implement ProjectRepository (AC: 2, 8)
  - [ ] Create `src/services/data/repositories/ProjectRepository.ts`
  - [ ] Implement `create(project: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<Project>`
  - [ ] Implement `getById(id: string): Promise<Project | undefined>`
  - [ ] Implement `getAll(): Promise<Project[]>`
  - [ ] Implement `getByClientId(clientId: string): Promise<Project[]>`
  - [ ] Implement `update(id: string, updates: Partial<Project>): Promise<Project>`
  - [ ] Implement `delete(id: string): Promise<void>`
  - [ ] Ensure all methods use async/await pattern
  - [ ] Ensure all methods handle errors appropriately
  - [ ] Ensure updatedAt timestamp is automatically set on updates
  - [ ] Validate that project requires valid clientId

- [ ] Task 7: Create DatabaseService for initialization (AC: 3)
  - [ ] Create `src/services/data/DatabaseService.ts` (or add to database.ts)
  - [ ] Implement `initialize(): Promise<void>` function
  - [ ] Handle database creation and version migrations
  - [ ] Set up migration strategy for future schema changes
  - [ ] Ensure initialization is idempotent (can be called multiple times safely)
  - [ ] Export initialization function for app startup

- [ ] Task 8: Implement comprehensive error handling (AC: 4)
  - [ ] Create custom error classes or error handling utilities
  - [ ] Handle QuotaExceededError for IndexedDB storage limits
  - [ ] Handle database connection errors
  - [ ] Handle transaction errors
  - [ ] Provide user-friendly error messages
  - [ ] Log errors for debugging (console.error)
  - [ ] Ensure all repository methods wrap errors appropriately

- [ ] Task 9: Create unit tests for repositories (AC: 5)
  - [ ] Set up mock IndexedDB using Dexie.js testing utilities or fake-indexeddb
  - [ ] Create `tests/unit/services/data/repositories/TaskRepository.test.ts`
  - [ ] Test TaskRepository CRUD operations:
    - [ ] Test create operation
    - [ ] Test getById operation
    - [ ] Test getAll operation
    - [ ] Test getByColumnId operation
    - [ ] Test getByClientId operation
    - [ ] Test getByProjectId operation
    - [ ] Test update operation
    - [ ] Test delete operation
    - [ ] Test error handling scenarios
  - [ ] Create `tests/unit/services/data/repositories/ClientRepository.test.ts`
  - [ ] Test ClientRepository CRUD operations
  - [ ] Create `tests/unit/services/data/repositories/ProjectRepository.test.ts`
  - [ ] Test ProjectRepository CRUD operations
  - [ ] Test database initialization
  - [ ] Verify all tests pass

- [ ] Task 10: Verify data persistence (AC: 6)
  - [ ] Create integration test or manual test script
  - [ ] Test: Create data, close browser, reopen browser, verify data still exists
  - [ ] Test: Create data, refresh page, verify data persists
  - [ ] Test: Create data, clear cache but keep IndexedDB, verify data persists
  - [ ] Document persistence verification results

- [ ] Task 11: Performance testing with 1000+ tasks (AC: 7)
  - [ ] Create performance test script or test case
  - [ ] Generate 1000+ test tasks programmatically
  - [ ] Measure time to:
    - [ ] Insert 1000 tasks
    - [ ] Query all tasks
    - [ ] Query tasks by columnId (using index)
    - [ ] Query tasks by clientId (using index)
    - [ ] Update a single task
    - [ ] Delete a single task
  - [ ] Verify all operations complete in reasonable time (< 1 second for queries)
  - [ ] Document performance test results
  - [ ] Ensure indexes are being used effectively

- [ ] Task 12: Integrate database initialization into app startup (AC: 3)
  - [ ] Call database initialization in `src/main.tsx` or `src/App.tsx`
  - [ ] Handle initialization errors gracefully
  - [ ] Show loading state during initialization if needed
  - [ ] Verify database is ready before app renders

- [ ] Task 13: Code quality and standards (AC: 8)
  - [ ] Ensure all repository methods use async/await (no callbacks)
  - [ ] Ensure all methods have proper TypeScript types (no `any`)
  - [ ] Follow naming conventions from coding standards
  - [ ] Add JSDoc comments to repository methods
  - [ ] Run linter and fix any issues
  - [ ] Ensure code follows repository pattern (no direct IndexedDB access from components)

## Dev Notes

### Previous Story Insights
[Source: Story 1.1]

**Key Learnings from Story 1.1:**
- Project structure is established: `src/services/data/` for data layer
- TypeScript is configured with strict mode and path aliases (@/ for src/)
- Testing infrastructure is set up (Jest, React Testing Library)
- Project uses Vite ^5.0.0, React ^18.2.0, TypeScript ^5.3.0
- Path aliases configured: `@/` maps to `src/`

**Important Notes:**
- All code must follow TypeScript strict mode (no `any` types)
- Use path aliases for imports (e.g., `import { Task } from '@/types/task'`)
- Follow naming conventions: Repositories use PascalCase classes
- One repository per file in `src/services/data/repositories/` directory

### Tech Stack Requirements
[Source: architecture/common/tech-stack.md]

**Critical Versions:**
- Dexie.js: ^3.2.4 (IndexedDB wrapper)
- TypeScript: ^5.3.0 (already installed in Story 1.1)
- Jest: ^29.7.0 (already installed in Story 1.1)

**Database Technology:**
- IndexedDB (browser-native, no installation needed)
- Dexie.js ^3.2.4 as wrapper library
- No backend database required (frontend-only application)

### Data Storage Architecture
[Source: architecture/common/data-storage-architecture.md]

**Why IndexedDB, not localStorage:**
- **Structured Data:** IndexedDB supports objects, arrays, relationships
- **Capacity:** Can store hundreds of MB (vs. ~5-10MB for localStorage)
- **Querying:** Supports complex queries, indexes, efficient filtering (essential for 1000+ tasks)
- **Performance:** Asynchronous operations don't block UI thread
- **Relationships:** Naturally supports relational data (tasks → clients, projects)

**Dexie.js Benefits:**
- Simpler, Promise-based API (vs. callback-based IndexedDB)
- Better TypeScript support
- Built-in schema management and migrations
- Efficient querying with indexes
- Better error handling

**What Gets Stored:**
- Task records
- Client records
- Project records
- (TimeEntry, Column, Subtask, TimerState, Settings will be added in later stories)

**Data Persistence:**
- Data persists across browser sessions
- Data persists when browser is closed and reopened
- Data is stored per browser/domain (not synced across devices)

### Database Schema
[Source: architecture/common/database-schema.md]

**Dexie.js Schema Definition:**
```typescript
import Dexie, { Table } from 'dexie';
import { Task } from '@/types/task';
import { Client } from '@/types/client';
import { Project } from '@/types/project';

class TimeTrackingDB extends Dexie {
  tasks!: Table<Task>;
  clients!: Table<Client>;
  projects!: Table<Project>;

  constructor() {
    super('TimeTrackingDB');
    
    this.version(1).stores({
      tasks: 'id, columnId, clientId, projectId, createdAt, updatedAt, [clientId+projectId]',
      clients: 'id, name, createdAt',
      projects: 'id, clientId, name, [clientId+name]'
    });
  }
}

export const db = new TimeTrackingDB();
```

**Index Strategy:**
[Source: architecture/common/database-schema.md#index-strategy]

**Tasks Table:**
- Primary key: `id`
- Indexes:
  - `columnId` - Fast filtering by column
  - `clientId` - Fast filtering by client
  - `projectId` - Fast filtering by project
  - `createdAt` - Sorting by creation date
  - `updatedAt` - Sorting by update date
  - `[clientId+projectId]` - Compound index for client/project queries

**Clients Table:**
- Primary key: `id`
- Indexes:
  - `name` - For searching/filtering clients
  - `createdAt` - Sorting by creation date

**Projects Table:**
- Primary key: `id`
- Indexes:
  - `clientId` - Fast lookup of projects by client
  - `[clientId+name]` - Compound index for unique project names per client

**Data Relationships:**
[Source: architecture/common/database-schema.md#data-relationships]
- Tasks → Clients (via `clientId`, nullable)
- Tasks → Projects (via `projectId`, nullable, requires `clientId`)
- Projects → Clients (via `clientId`)

### Data Models
[Source: architecture/common/data-models.md]

**Task Interface:**
```typescript
interface Task {
  id: string;
  title: string;
  description?: string;
  columnId: string;
  position: number;
  clientId: string | null;
  projectId: string | null;
  isBillable: boolean;
  hourlyRate: number | null;
  timeEstimate: number | null; // in minutes
  dueDate: Date | null;
  priority: 'low' | 'medium' | 'high' | null;
  tags: string[];
  createdAt: Date;
  updatedAt: Date;
}
```

**Client Interface:**
```typescript
interface Client {
  id: string;
  name: string;
  defaultHourlyRate: number | null;
  contactInfo: string | null;
  createdAt: Date;
  updatedAt: Date;
}
```

**Project Interface:**
```typescript
interface Project {
  id: string;
  clientId: string;
  name: string;
  description?: string;
  defaultHourlyRate: number | null;
  createdAt: Date;
  updatedAt: Date;
}
```

**Important Notes:**
- All IDs are strings (UUIDs)
- Dates are stored as Date objects (Dexie.js handles serialization)
- `projectId` requires `clientId` (validation needed in ProjectRepository)
- `createdAt` and `updatedAt` are automatically managed

### Repository Pattern
[Source: architecture/common/coding-standards.md, architecture/components.md#data-access-layer]

**Critical Rule:**
- **Data Access:** Always use repository pattern, never access IndexedDB directly from components
- Components must use repositories, not `db.tasks.get()` directly
- This enables testing, maintains separation of concerns, allows future storage changes

**Repository Structure:**
- Location: `src/services/data/repositories/`
- One repository per entity: `TaskRepository.ts`, `ClientRepository.ts`, `ProjectRepository.ts`
- Each repository is a class with methods for CRUD operations
- Repositories use the exported `db` instance from `database.ts`

**Repository Method Pattern:**
```typescript
export class TaskRepository {
  async create(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<Task> {
    const now = new Date();
    const newTask: Task = {
      ...task,
      id: crypto.randomUUID(),
      createdAt: now,
      updatedAt: now
    };
    await db.tasks.add(newTask);
    return newTask;
  }

  async getById(id: string): Promise<Task | undefined> {
    return await db.tasks.get(id);
  }

  // ... other methods
}
```

### Migration Strategy
[Source: architecture/common/database-schema.md#migration-strategy]

**Migration Process:**
1. Version increment: Increment version number in Dexie schema definition
2. Migration callbacks: Define migration functions for data transformation
3. Automatic index updates: Dexie.js automatically creates/updates indexes
4. Data transformation: Use migration callbacks for data structure changes

**Initial Migration (Version 1):**
- No data transformation needed (initial schema)
- Indexes are automatically created
- Can seed default data if needed (not required for Story 1.2)

**Migration Best Practices:**
- Always test migrations with production-like data
- Use transactions for atomic migrations (Dexie handles this)
- Handle edge cases (null values, missing fields)
- Version incrementally (don't skip versions)

### Error Handling
[Source: architecture/common/coding-standards.md, architecture/common/error-handling-strategy.md]

**Critical Rules:**
- All async operations must have try/catch
- Use Error Boundaries for component errors (not applicable to repositories)
- Provide user-friendly error messages

**Common IndexedDB Errors:**
- `QuotaExceededError`: Storage limit exceeded
  - Solution: Catch error, provide user feedback, offer export option
- `TransactionInactiveError`: Transaction expired
  - Solution: Retry operation or handle gracefully
- `ConstraintError`: Unique constraint violation
  - Solution: Validate data before insert, provide clear error message

**Error Handling Pattern:**
```typescript
async create(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<Task> {
  try {
    // ... create logic
  } catch (error) {
    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
      throw new Error('Storage limit exceeded. Please export some data to free up space.');
    }
    throw new Error(`Failed to create task: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}
```

### Project Structure
[Source: architecture/unified-project-structure.md]

**File Locations:**
- Database schema: `src/services/data/database.ts`
- Repositories: `src/services/data/repositories/`
  - `TaskRepository.ts`
  - `ClientRepository.ts`
  - `ProjectRepository.ts`
- Type definitions: `src/types/`
  - `task.ts`
  - `client.ts`
  - `project.ts`
- Tests: `tests/unit/services/data/repositories/`

### Coding Standards
[Source: architecture/common/coding-standards.md]

**Critical Rules:**
- **Type Safety:** Always use TypeScript types/interfaces, avoid `any`
- **Data Access:** Always use repository pattern, never access IndexedDB directly from components
- **Error Handling:** All async operations must have try/catch
- **Naming Conventions:**
  - Services/Repositories: PascalCase classes (e.g., `TaskRepository.ts`)
  - Types/Interfaces: PascalCase (e.g., `Task`, `Client`)
  - Test files: `.test.ts` (e.g., `TaskRepository.test.ts`)

**Common Pitfall to Avoid:**
- ❌ **Pitfall:** Accessing `db.tasks.get()` directly in components
- ✅ **Solution:** Always use repository pattern: `taskRepository.getById(id)`
- **Why:** Enables testing, maintains separation of concerns, allows future storage changes

### Testing Requirements
[Source: architecture/common/testing-strategy.md]

**Test Organization:**
- Unit tests: `tests/unit/services/data/repositories/`
- Test file naming: `{RepositoryName}.test.ts`

**Testing Frameworks:**
- Jest ^29.7.0 for unit testing
- Mock IndexedDB: Use `fake-indexeddb` or Dexie.js testing utilities

**Test Standards:**
- Write tests for all CRUD operations
- Test error handling scenarios
- Test edge cases (null values, missing data)
- Use descriptive test names
- Follow Arrange-Act-Assert pattern

**Mock IndexedDB Setup:**
```typescript
import 'fake-indexeddb/auto';
import { TaskRepository } from '@/services/data/repositories/TaskRepository';

describe('TaskRepository', () => {
  beforeEach(async () => {
    // Reset database before each test
    await db.tasks.clear();
  });

  it('creates a task successfully', async () => {
    // Test implementation
  });
});
```

**Performance Testing:**
- Create test that generates 1000+ tasks
- Measure query performance
- Verify indexes are being used
- Ensure operations complete in reasonable time (< 1 second)

### Performance Considerations
[Source: Epic 1.2 Acceptance Criteria, architecture/common/database-schema.md]

**Performance Requirements:**
- Database must handle at least 1000 tasks without performance degradation
- Queries should use indexes for efficient filtering
- All operations should complete in reasonable time (< 1 second for queries)

**Optimization Strategies:**
- Use indexes for common queries (columnId, clientId, projectId)
- Use compound indexes for multi-field queries ([clientId+projectId])
- Avoid loading all data into memory (use Dexie queries)
- Test with large datasets (1000+ tasks)

### Technical Constraints
[Source: architecture/common/tech-stack.md, architecture/common/data-storage-architecture.md]

- No backend services - frontend-only application
- No external API - all data processing client-side
- Local-first architecture - IndexedDB is the only data store
- Data is stored per browser/domain (not synced across devices)
- IndexedDB quota limits vary by browser (typically 50% of available disk space)

### Testing

#### Testing Standards
[Source: architecture/common/testing-strategy.md]

**Test File Location:**
- Unit tests: `tests/unit/services/data/repositories/` directory

**Testing Frameworks:**
- Jest ^29.7.0 for unit testing
- Mock IndexedDB: `fake-indexeddb` package for testing

**Test Standards:**
- Write tests for all CRUD operations
- Test error handling scenarios
- Test edge cases (null values, missing data, invalid IDs)
- Use descriptive test names
- Follow Arrange-Act-Assert pattern
- Aim for high test coverage (80%+)

**Test Examples:**
[Source: architecture/common/testing-strategy.md]

**Repository Test Example:**
```typescript
import 'fake-indexeddb/auto';
import { TaskRepository } from '@/services/data/repositories/TaskRepository';
import { db } from '@/services/data/database';

describe('TaskRepository', () => {
  let repository: TaskRepository;

  beforeEach(async () => {
    repository = new TaskRepository();
    await db.tasks.clear();
  });

  it('creates a task successfully', async () => {
    const taskData = {
      title: 'Test Task',
      columnId: 'column-1',
      clientId: null,
      projectId: null,
      isBillable: false,
      hourlyRate: null,
      timeEstimate: null,
      dueDate: null,
      priority: null,
      tags: []
    };

    const task = await repository.create(taskData);
    
    expect(task.id).toBeDefined();
    expect(task.title).toBe('Test Task');
    expect(task.createdAt).toBeInstanceOf(Date);
    expect(task.updatedAt).toBeInstanceOf(Date);
  });

  it('handles QuotaExceededError gracefully', async () => {
    // Test error handling
  });
});
```

**Performance Test Example:**
```typescript
describe('TaskRepository Performance', () => {
  it('handles 1000+ tasks efficiently', async () => {
    const repository = new TaskRepository();
    
    // Create 1000 tasks
    const startTime = Date.now();
    for (let i = 0; i < 1000; i++) {
      await repository.create({
        title: `Task ${i}`,
        columnId: 'column-1',
        // ... other required fields
      });
    }
    const createTime = Date.now() - startTime;
    
    // Query all tasks
    const queryStart = Date.now();
    const tasks = await repository.getAll();
    const queryTime = Date.now() - queryStart;
    
    expect(tasks.length).toBe(1000);
    expect(queryTime).toBeLessThan(1000); // Should complete in < 1 second
  });
});
```

**Specific Testing Requirements for This Story:**
- Test all CRUD operations for TaskRepository
- Test all CRUD operations for ClientRepository
- Test all CRUD operations for ProjectRepository
- Test database initialization
- Test error handling (QuotaExceededError, invalid data)
- Test data persistence (integration test)
- Test performance with 1000+ tasks
- Verify all tests pass before marking story complete

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-19 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA Agent_
