# Story 2.1: Timer Controls on Task Cards

## Status
Draft

## Story
**As a** user,
**I want** to start and stop a timer directly on task cards,
**so that** I can track time spent on tasks without leaving the kanban board.

## Acceptance Criteria

1. Timer control button/icon displays on each task card
2. Timer button shows "Start" state when no timer is active for the task
3. Clicking start button initiates timer and button changes to "Stop" state
4. Clicking stop button stops timer and saves time entry to IndexedDB
5. Only one timer can be active at a time across all tasks (starting new timer stops previous)
6. Visual indicator (e.g., pulsing animation, color change) shows which task has active timer
7. Timer control is accessible via keyboard navigation
8. Timer state persists across browser refresh (if timer was active, it resumes or shows last state)
9. Timer control is clearly visible and doesn't clutter task card design
10. Timer button provides clear visual feedback on hover and click states

## Tasks / Subtasks

- [ ] Task 1: Create TimerState data model and repository (AC: 4, 8)
  - [ ] Verify `src/types/task.ts` exists (from Story 1.2)
  - [ ] Create `src/types/timerState.ts` with TimerState interface
  - [ ] Update `src/services/data/database.ts` to add timerState table to Dexie schema
  - [ ] Create `src/services/data/repositories/TimerStateRepository.ts` with CRUD operations
  - [ ] Ensure TimerStateRepository follows async/await pattern
  - [ ] Add timerState table to database schema with taskId as primary key

- [ ] Task 2: Create TimeEntry data model and repository (AC: 4)
  - [ ] Create `src/types/timeEntry.ts` with TimeEntry interface
  - [ ] Update `src/services/data/database.ts` to add timeEntries table to Dexie schema
  - [ ] Create `src/services/data/repositories/TimeEntryRepository.ts` with CRUD operations
  - [ ] Ensure TimeEntryRepository follows async/await pattern
  - [ ] Add timeEntries table to database schema with proper indexes (taskId, startTime)

- [ ] Task 3: Create TimerContext for state management (AC: 3, 4, 5, 8)
  - [ ] Create `src/contexts/TimerContext.tsx`
  - [ ] Implement TimerProvider component
  - [ ] Manage timer state: activeTaskId, startTime, elapsedTime, status
  - [ ] Provide methods: startTimer(taskId), stopTimer(), getElapsedTime()
  - [ ] Enforce single active timer rule (stop previous timer when starting new one)
  - [ ] Load timer state from IndexedDB on mount (for persistence across refresh)
  - [ ] Persist timer state to IndexedDB on start/stop operations
  - [ ] Ensure optimistic updates for better UX
  - [ ] Handle edge cases: rapid start/stop, browser refresh during timer

- [ ] Task 4: Create TimerService for business logic (AC: 3, 4, 5)
  - [ ] Create `src/services/TimerService.ts`
  - [ ] Implement startTimer(taskId: string) method
  - [ ] Implement stopTimer() method that creates TimeEntry
  - [ ] Integrate with TimerStateRepository for persistence
  - [ ] Integrate with TimeEntryRepository for saving time entries
  - [ ] Ensure only one timer can be active (stop previous timer before starting new)
  - [ ] Calculate duration in minutes when stopping timer
  - [ ] Handle errors gracefully (try/catch, user feedback)

- [ ] Task 5: Create TimerControl component (AC: 1, 2, 3, 4, 6, 9, 10)
  - [ ] Create `src/components/timer/TimerControl.tsx`
  - [ ] Accept taskId as prop
  - [ ] Use TimerContext to check if this task has active timer
  - [ ] Display "Start" button when timer is not active for this task
  - [ ] Display "Stop" button when timer is active for this task
  - [ ] Add visual indicator (pulsing animation, color change) when timer is active
  - [ ] Implement onClick handler to start/stop timer
  - [ ] Add hover states for better UX
  - [ ] Ensure button is clearly visible but doesn't clutter card design
  - [ ] Use Tailwind CSS for styling
  - [ ] Ensure component is accessible (ARIA labels, keyboard navigation)

- [ ] Task 6: Integrate TimerControl into TaskCard (AC: 1, 9)
  - [ ] Update `src/components/kanban/TaskCard.tsx`
  - [ ] Import TimerControl component
  - [ ] Add TimerControl to TaskCard layout
  - [ ] Position timer control appropriately (e.g., top-right corner or header area)
  - [ ] Ensure timer control doesn't interfere with existing TaskCard functionality
  - [ ] Ensure timer control is visible on all task cards

- [ ] Task 7: Add TimerContext Provider to app root (AC: 3, 4, 5, 8)
  - [ ] Update `src/App.tsx` or `src/main.tsx`
  - [ ] Import TimerProvider from TimerContext
  - [ ] Wrap application with TimerProvider
  - [ ] Ensure TimerProvider loads timer state from IndexedDB on mount
  - [ ] Ensure TimerProvider is available to all components

- [ ] Task 8: Implement timer state persistence (AC: 8)
  - [ ] Ensure TimerContext saves timer state to IndexedDB on start
  - [ ] Ensure TimerContext saves timer state to IndexedDB on stop
  - [ ] Ensure TimerContext loads timer state from IndexedDB on mount
  - [ ] Handle case where timer was active before refresh (resume or show last state)
  - [ ] Test persistence across browser refresh

- [ ] Task 9: Implement keyboard accessibility (AC: 7)
  - [ ] Add keyboard event handlers to TimerControl
  - [ ] Support Enter/Space key to start/stop timer
  - [ ] Add ARIA labels and roles for screen readers
  - [ ] Ensure focus management (focus visible on keyboard navigation)
  - [ ] Test with keyboard-only navigation

- [ ] Task 10: Add visual feedback and animations (AC: 6, 10)
  - [ ] Add pulsing animation to active timer indicator
  - [ ] Add color change (e.g., green/red) for active timer
  - [ ] Add hover states with visual feedback
  - [ ] Add click/tap feedback (e.g., scale animation)
  - [ ] Ensure animations are performant (use CSS transforms)
  - [ ] Consider prefers-reduced-motion for accessibility

- [ ] Task 11: Unit tests for TimerContext (AC: 3, 4, 5, 8)
  - [ ] Create `tests/unit/contexts/TimerContext.test.tsx`
  - [ ] Test startTimer() functionality
  - [ ] Test stopTimer() functionality
  - [ ] Test single active timer enforcement
  - [ ] Test timer state persistence
  - [ ] Test edge cases (rapid start/stop, browser refresh)
  - [ ] Mock IndexedDB operations

- [ ] Task 12: Unit tests for TimerService (AC: 3, 4, 5)
  - [ ] Create `tests/unit/services/TimerService.test.ts`
  - [ ] Test startTimer() method
  - [ ] Test stopTimer() method and TimeEntry creation
  - [ ] Test single active timer enforcement
  - [ ] Test duration calculation
  - [ ] Test error handling
  - [ ] Mock repositories

- [ ] Task 13: Unit tests for TimerControl component (AC: 1, 2, 3, 4, 6, 7, 9, 10)
  - [ ] Create `tests/unit/components/timer/TimerControl.test.tsx`
  - [ ] Test rendering of Start button when timer inactive
  - [ ] Test rendering of Stop button when timer active
  - [ ] Test start timer on click
  - [ ] Test stop timer on click
  - [ ] Test visual indicator when active
  - [ ] Test keyboard accessibility (Enter/Space)
  - [ ] Test ARIA attributes
  - [ ] Mock TimerContext

- [ ] Task 14: Integration tests for timer workflow (AC: 1-10)
  - [ ] Create `tests/integration/TimerWorkflow.test.tsx`
  - [ ] Test complete timer start/stop workflow
  - [ ] Test timer state persistence across refresh
  - [ ] Test single active timer enforcement
  - [ ] Test TimeEntry creation on stop
  - [ ] Test visual feedback and animations
  - [ ] Use React Testing Library

- [ ] Task 15: Code quality and accessibility review (AC: 7, 9, 10)
  - [ ] Ensure all components use TypeScript (no `any`)
  - [ ] Add ARIA labels to TimerControl
  - [ ] Ensure semantic HTML structure
  - [ ] Test with screen reader
  - [ ] Ensure keyboard navigation works
  - [ ] Add JSDoc comments to components and services
  - [ ] Run linter and fix any issues
  - [ ] Ensure code follows component template pattern
  - [ ] Verify all acceptance criteria are met

## Dev Notes

### Previous Story Insights
[Source: Story 1.1, Story 1.2, Story 1.4, Story 1.5, Story 1.6]

**Key Learnings from Story 1.1:**
- Project structure is established: `src/components/`, `src/contexts/`, `src/services/`, `src/hooks/`
- Vite ^5.0.0 is configured as build tool
- TypeScript is configured with strict mode and path aliases (@/ for src/)
- Tailwind CSS ^3.4.0 is configured for styling
- Project uses React ^18.2.0, TypeScript ^5.3.0

**Key Learnings from Story 1.2:**
- IndexedDB is set up with Dexie.js ^3.2.4
- TaskRepository is implemented with CRUD operations
- Task data model is defined
- Database operations use async/await pattern
- Database schema is defined in `src/services/data/database.ts`

**Key Learnings from Story 1.4:**
- ColumnContext is implemented for column state management
- KanbanBoard and Column components are created
- Columns are stored in IndexedDB
- Default columns: Backlog, In Progress, Review, Done

**Key Learnings from Story 1.5:**
- TaskContext is implemented for task state management
- TaskCard component exists and displays task information
- TaskForm and TaskCreationModal are implemented
- Tasks are persisted to IndexedDB via TaskRepository

**Key Learnings from Story 1.6:**
- Drag-and-drop is implemented using @dnd-kit/core ^6.0.0
- SortableTaskCard wraps TaskCard for drag functionality
- TaskCard is already created and styled with Tailwind CSS
- TaskContext.updateTask() is used for moving tasks

**Important Notes:**
- TaskCard component already exists (created in Story 1.5)
- TaskContext already exists (created in Story 1.5)
- Need to create TimerContext (similar pattern to TaskContext)
- Need to create TimerService for business logic
- Need to integrate TimerControl into existing TaskCard component
- Timer state must persist to IndexedDB for AC 8 (persistence across refresh)

### Tech Stack Requirements
[Source: architecture/common/tech-stack.md]

**Critical Versions:**
- React: ^18.2.0 (already installed)
- TypeScript: ^5.3.0 (already installed)
- Tailwind CSS: ^3.4.0 (already installed)
- Dexie.js: ^3.2.4 (already installed)

**No Additional Dependencies Required:**
- Use React Context API (built-in) for state management
- Use native CSS animations for visual indicators
- No external timer library needed for MVP

### Data Models
[Source: architecture/common/data-models.md#timerstate, architecture/common/data-models.md#timeentry]

**TimerState Interface:**
```typescript
interface TimerState {
  taskId: string;
  startTime: Date;
  lastUpdateTime: Date;
  status: 'active' | 'paused' | 'stopped';
}
```

**Key Attributes:**
- `taskId`: string - ID of the task with active timer (primary key)
- `startTime`: Date - Timestamp when timer started
- `lastUpdateTime`: Date - Last time timer state was updated (for background sync)
- `status`: 'active' | 'paused' | 'stopped' - Current timer status

**TimeEntry Interface:**
```typescript
interface TimeEntry {
  id: string;
  taskId: string;
  startTime: Date;
  endTime: Date | null;
  duration: number; // in minutes
  isManual: boolean;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}
```

**Key Attributes:**
- `id`: string - Unique identifier (UUID)
- `taskId`: string - Reference to the task this time entry belongs to
- `startTime`: Date - Start timestamp of the time entry
- `endTime`: Date | null - End timestamp (null if timer is still running)
- `duration`: number - Duration in minutes (calculated or manually entered)
- `isManual`: boolean - Whether this entry was manually added (vs. tracked by timer)
- `description`: string | null - Optional notes/description for this time entry

**Relationships:**
- TimerState references one Task (via `taskId`)
- TimeEntry belongs to one Task (via `taskId`)

### Database Schema
[Source: architecture/common/database-schema.md]

**Dexie.js Schema Updates Required:**
```typescript
// Add to existing database.ts schema
timerState: 'taskId',  // Primary key: taskId (unique, only one active timer)
timeEntries: 'id, taskId, startTime, endTime, [taskId+startTime]'
```

**Index Strategy:**
- `timerState`: Indexed by `taskId` (unique, only one active timer)
- `timeEntries`: 
  - Primary key: `id`
  - Indexes: `taskId` (fast lookup of all entries for a task), `startTime` (sorting and date range queries), `[taskId+startTime]` (compound index for task time entry queries)

**Migration Strategy:**
- Add new tables to existing Dexie schema (version increment)
- No data migration needed (new tables)
- Ensure indexes are created correctly

### Repository Pattern
[Source: Story 1.2, architecture/common/coding-standards.md]

**TimerStateRepository:**
- Location: `src/services/data/repositories/TimerStateRepository.ts`
- Methods: `getActive()`, `save(state: TimerState)`, `delete(taskId: string)`, `clear()`
- Pattern: Follow same pattern as TaskRepository (async/await, error handling)
- Never access IndexedDB directly from components - always use repository

**TimeEntryRepository:**
- Location: `src/services/data/repositories/TimeEntryRepository.ts`
- Methods: `create(entry: TimeEntry)`, `getByTaskId(taskId: string)`, `getAll()`, `update(id: string, entry: Partial<TimeEntry>)`, `delete(id: string)`
- Pattern: Follow same pattern as TaskRepository (async/await, error handling)
- Never access IndexedDB directly from components - always use repository

### State Management Architecture
[Source: architecture/common/frontend-architecture.md#state-management-architecture]

**TimerContext State Structure:**
```typescript
interface TimerState {
  activeTaskId: string | null;
  startTime: Date | null;
  elapsedTime: number; // in seconds
  status: 'idle' | 'active' | 'paused';
}
```

**TimerContext Methods:**
- `startTimer(taskId: string): Promise<void>` - Start timer for a task
- `stopTimer(): Promise<TimeEntry>` - Stop active timer and save time entry
- `getElapsedTime(): number` - Get elapsed time for active timer (in seconds)
- `isActive(taskId: string): boolean` - Check if timer is active for a task

**State Management Patterns:**
- Use React Context API (built-in, no Redux needed)
- Optimistic updates for better UX (update UI immediately, then sync with IndexedDB)
- Load timer state from IndexedDB on mount (for persistence across refresh)
- Persist timer state to IndexedDB on start/stop operations
- Enforce single active timer rule (stop previous timer when starting new one)

### Component Architecture
[Source: architecture/common/frontend-architecture.md#component-architecture]

**TimerControl Component:**
- Location: `src/components/timer/TimerControl.tsx`
- Props: `taskId: string`
- Uses: TimerContext to check timer state and start/stop timer
- Styling: Tailwind CSS (consistent with existing TaskCard styling)
- Accessibility: ARIA labels, keyboard navigation support

**Component Template Pattern:**
```typescript
import React from 'react';
import { useTimerContext } from '@/contexts/TimerContext';

interface TimerControlProps {
  taskId: string;
}

export const TimerControl: React.FC<TimerControlProps> = ({ taskId }) => {
  const { activeTaskId, startTimer, stopTimer } = useTimerContext();
  const isActive = activeTaskId === taskId;
  
  // Component logic
  
  return (
    <button
      onClick={handleClick}
      aria-label={isActive ? 'Stop timer' : 'Start timer'}
      className="..."
    >
      {/* JSX */}
    </button>
  );
};
```

### Timer Service
[Source: architecture/components.md#timer-service, architecture/common/frontend-architecture.md#service-example]

**TimerService Responsibilities:**
- Manages timer functionality including active timer state
- Handles timer start/stop operations
- Creates TimeEntry records when timer stops
- Persists timer state to IndexedDB
- Integrates with TimerContext for state management

**TimerService Methods:**
```typescript
class TimerService {
  async startTimer(taskId: string): Promise<void>
  async stopTimer(): Promise<TimeEntry>
  async getElapsedTime(taskId: string): Promise<number>
}
```

**Implementation Notes:**
- Stop any active timer before starting new one (enforce single active timer)
- Save timer state to IndexedDB immediately on start
- Calculate duration in minutes when stopping timer
- Create TimeEntry record with proper fields (id, taskId, startTime, endTime, duration, isManual: false)
- Handle errors gracefully (try/catch, user feedback)

### Core Workflow
[Source: architecture/core-workflows.md#workflow-1-start-timer-on-task]

**Start Timer Workflow:**
1. User clicks timer button on TaskCard
2. TimerControl calls TimerContext.startTimer(taskId)
3. TimerContext checks if timer is already active
4. If active, stop previous timer first
5. TimerService saves TimerState to IndexedDB
6. TimerContext updates state (activeTaskId, startTime, status: 'active')
7. TaskCard re-renders with active timer indicator

**Stop Timer Workflow:**
1. User clicks stop button on TaskCard
2. TimerControl calls TimerContext.stopTimer()
3. TimerService calculates duration (endTime - startTime in minutes)
4. TimerService creates TimeEntry record
5. TimerService saves TimeEntry to IndexedDB
6. TimerService deletes TimerState from IndexedDB
7. TimerContext updates state (activeTaskId: null, status: 'idle')
8. TaskCard re-renders without active timer indicator

### File Locations
[Source: architecture/unified-project-structure.md, architecture/common/frontend-architecture.md]

**New Files to Create:**
- `src/types/timerState.ts` - TimerState interface
- `src/types/timeEntry.ts` - TimeEntry interface
- `src/contexts/TimerContext.tsx` - Timer state management
- `src/services/TimerService.ts` - Timer business logic
- `src/services/data/repositories/TimerStateRepository.ts` - TimerState data access
- `src/services/data/repositories/TimeEntryRepository.ts` - TimeEntry data access
- `src/components/timer/TimerControl.tsx` - Timer control UI component
- `tests/unit/contexts/TimerContext.test.tsx` - TimerContext tests
- `tests/unit/services/TimerService.test.ts` - TimerService tests
- `tests/unit/components/timer/TimerControl.test.tsx` - TimerControl tests
- `tests/integration/TimerWorkflow.test.tsx` - Integration tests

**Files to Modify:**
- `src/services/data/database.ts` - Add timerState and timeEntries tables to Dexie schema
- `src/components/kanban/TaskCard.tsx` - Add TimerControl component
- `src/App.tsx` or `src/main.tsx` - Add TimerProvider wrapper

### Testing Requirements
[Source: architecture/common/testing-strategy.md]

**Unit Tests:**
- TimerContext: Test startTimer(), stopTimer(), state management, persistence
- TimerService: Test startTimer(), stopTimer(), TimeEntry creation, error handling
- TimerControl: Test rendering, click handlers, keyboard accessibility, ARIA attributes

**Integration Tests:**
- Complete timer workflow: start → stop → TimeEntry creation
- Timer state persistence across refresh
- Single active timer enforcement
- Visual feedback and animations

**Test Organization:**
- Unit tests: `tests/unit/contexts/`, `tests/unit/services/`, `tests/unit/components/timer/`
- Integration tests: `tests/integration/TimerWorkflow.test.tsx`
- Use Jest + React Testing Library for unit/integration tests
- Mock IndexedDB operations and repositories

**Test Examples:**
```typescript
// TimerContext test example
describe('TimerContext', () => {
  it('starts timer and updates state', async () => {
    // Test implementation
  });
  
  it('enforces single active timer', async () => {
    // Test implementation
  });
});
```

### Accessibility Requirements
[Source: architecture/common/accessibility-implementation.md]

**WCAG 2.1 AA Compliance:**
- Keyboard navigation: TimerControl must be accessible via keyboard (Enter/Space keys)
- ARIA labels: Add proper ARIA labels and roles
- Focus management: Ensure focus is visible on keyboard navigation
- Screen reader support: Test with screen reader
- Visual indicators: Ensure visual indicators don't rely solely on color

**Accessibility Checklist:**
- [ ] TimerControl has ARIA label
- [ ] TimerControl has keyboard event handlers (Enter/Space)
- [ ] Focus is visible on keyboard navigation
- [ ] Visual indicators have text alternatives
- [ ] Tested with screen reader

### Coding Standards
[Source: architecture/common/coding-standards.md]

**Critical Rules:**
- Type Safety: Always use TypeScript types/interfaces, avoid `any`
- Component Organization: One component per file, co-locate related components
- State Management: Use Context API, avoid prop drilling beyond 2 levels
- Data Access: Always use repository pattern, never access IndexedDB directly from components
- Error Handling: All async operations must have try/catch, use Error Boundaries for component errors
- Performance: Use React.memo, useMemo, useCallback appropriately, avoid unnecessary re-renders
- Accessibility: All interactive elements must have ARIA labels, keyboard navigation support

**Naming Conventions:**
- Components: PascalCase (e.g., `TimerControl.tsx`)
- Hooks: camelCase with 'use' (e.g., `useTimer.ts`)
- Services: PascalCase classes (e.g., `TimerService.ts`)
- Types/Interfaces: PascalCase (e.g., `TimerState`, `TimeEntry`)

### Project Structure Notes
[Source: architecture/unified-project-structure.md]

**Component Organization:**
- Timer components go in `src/components/timer/` directory
- Timer context goes in `src/contexts/` directory
- Timer service goes in `src/services/` directory
- Timer repositories go in `src/services/data/repositories/` directory
- Timer types go in `src/types/` directory

**Integration Points:**
- TimerControl integrates into existing TaskCard component (from Story 1.5)
- TimerContext integrates with existing TaskContext (if needed for task updates)
- TimerService integrates with TimerStateRepository and TimeEntryRepository
- TimerProvider wraps application in App.tsx or main.tsx

### Testing
[Source: architecture/common/testing-strategy.md]

**Test File Location:**
- Unit tests: `tests/unit/contexts/`, `tests/unit/services/`, `tests/unit/components/timer/`
- Integration tests: `tests/integration/`

**Test Standards:**
- Use Jest ^29.7.0 for unit testing
- Use React Testing Library ^14.0.0 for component testing
- Follow Arrange-Act-Assert pattern
- Mock IndexedDB operations and repositories
- Aim for 80%+ code coverage

**Test Examples:**
```typescript
// Component test example
import { render, screen, fireEvent } from '@testing-library/react';
import { TimerControl } from '@/components/timer/TimerControl';
import { TimerContextProvider } from '@/contexts/TimerContext';

describe('TimerControl', () => {
  it('displays Start button when timer inactive', () => {
    // Test implementation
  });
  
  it('starts timer when Start button clicked', async () => {
    // Test implementation
  });
});
```

**Specific Test Requirements:**
- Test timer start/stop functionality
- Test single active timer enforcement
- Test timer state persistence
- Test TimeEntry creation on stop
- Test keyboard accessibility
- Test visual feedback and animations
- Test edge cases (rapid start/stop, browser refresh)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-19 | 1.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA Agent_
