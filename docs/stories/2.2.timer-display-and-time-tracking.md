# Story 2.2: Timer Display and Time Tracking

## Status
Draft

## Story
**As a** user,
**I want** to see elapsed time displayed on task cards,
**so that** I know how much time I've spent on each task.

## Acceptance Criteria

1. Active timer displays elapsed time on task card (updates every second)
2. Time format is human-readable (e.g., "1h 23m" or "83m")
3. Elapsed time updates in real-time while timer is running
4. Total time spent displays on task card when timer is stopped
5. Time display persists across browser sessions (loaded from IndexedDB)
6. Time entries are stored with task ID, start time, end time, and duration
7. Multiple time entries per task are supported (can track time in multiple sessions)
8. Time display is clearly visible but doesn't dominate task card
9. Time format is consistent across all task cards
10. Time calculations are accurate (no drift or rounding errors)

## Tasks / Subtasks

- [ ] Task 1: Create time formatting utility functions (AC: 2, 9, 10)
  - [ ] Create `src/utils/timeUtils.ts`
  - [ ] Implement `formatDuration(minutes: number): string` function
  - [ ] Format logic: "1h 23m" for hours+minutes, "83m" for minutes only
  - [ ] Handle edge cases: 0 minutes, large durations, rounding
  - [ ] Ensure consistent formatting across all uses
  - [ ] Add JSDoc comments
  - [ ] Write unit tests for formatDuration function

- [ ] Task 2: Create TimerDisplay component (AC: 1, 2, 3, 8, 9)
  - [ ] Create `src/components/timer/TimerDisplay.tsx`
  - [ ] Accept taskId and optional displayMode prop ('elapsed' | 'total')
  - [ ] Use TimerContext to get active timer state and elapsed time
  - [ ] Use TimeEntryRepository to get total time for task
  - [ ] Display elapsed time when timer is active for this task
  - [ ] Display total time when timer is stopped
  - [ ] Use formatDuration utility for consistent formatting
  - [ ] Style with Tailwind CSS (subtle, doesn't dominate card)
  - [ ] Ensure component is accessible (ARIA labels)
  - [ ] Add loading state while fetching time entries

- [ ] Task 3: Implement real-time elapsed time updates (AC: 1, 3, 10)
  - [ ] Update TimerContext to track elapsed time in state
  - [ ] Use useEffect with setInterval to update elapsed time every second
  - [ ] Calculate elapsed time: current time - startTime (in seconds)
  - [ ] Convert seconds to minutes for display
  - [ ] Clean up interval on unmount or timer stop
  - [ ] Ensure accurate time calculation (use Date.now() for precision)
  - [ ] Handle edge cases: timer stopped during update, rapid start/stop
  - [ ] Optimize to prevent unnecessary re-renders (use useMemo/useCallback)

- [ ] Task 4: Calculate total time spent from TimeEntry records (AC: 4, 5, 7, 10)
  - [ ] Create helper function in TimeEntryRepository: `getTotalTimeForTask(taskId: string): Promise<number>`
  - [ ] Query all time entries for task from IndexedDB
  - [ ] Sum duration from all time entries (in minutes)
  - [ ] Handle case where no time entries exist (return 0)
  - [ ] Ensure accurate summation (no rounding errors)
  - [ ] Cache total time calculation to avoid repeated queries
  - [ ] Invalidate cache when new time entry is created

- [ ] Task 5: Integrate TimerDisplay into TaskCard (AC: 1, 4, 8)
  - [ ] Update `src/components/kanban/TaskCard.tsx`
  - [ ] Import TimerDisplay component
  - [ ] Add TimerDisplay to TaskCard layout
  - [ ] Position time display appropriately (e.g., below title or in footer)
  - [ ] Ensure time display doesn't interfere with existing TaskCard elements
  - [ ] Ensure time display is visible on all task cards
  - [ ] Style consistently with TaskCard design

- [ ] Task 6: Load total time on TaskCard mount (AC: 4, 5)
  - [ ] Update TaskCard to load time entries on mount
  - [ ] Use TimeEntryRepository.getByTaskId() to fetch entries
  - [ ] Calculate and display total time
  - [ ] Handle loading state (show placeholder or spinner)
  - [ ] Handle error state (graceful degradation)
  - [ ] Optimize: only load when TaskCard is visible (lazy loading)

- [ ] Task 7: Update TimerContext to expose elapsed time (AC: 1, 3)
  - [ ] Update TimerContext to calculate and expose elapsedTime
  - [ ] Add getElapsedTime(taskId: string): number method
  - [ ] Return elapsed time in seconds (for precise calculations)
  - [ ] Update elapsed time every second when timer is active
  - [ ] Ensure elapsed time is 0 when timer is not active
  - [ ] Expose elapsed time in context value

- [ ] Task 8: Subscribe to TimeEntry changes for real-time updates (AC: 4, 5)
  - [ ] Create mechanism to notify components when time entries change
  - [ ] Update TimerContext to emit events when timer stops (creates TimeEntry)
  - [ ] Update TaskCard to listen for time entry changes
  - [ ] Recalculate total time when new time entry is created
  - [ ] Use React Context or custom event system for notifications
  - [ ] Ensure updates don't cause unnecessary re-renders

- [ ] Task 9: Handle timer state persistence and resume (AC: 5)
  - [ ] Ensure TimerContext loads timer state from IndexedDB on mount
  - [ ] If timer was active before refresh, resume elapsed time calculation
  - [ ] Calculate elapsed time from stored startTime to current time
  - [ ] Display correct elapsed time immediately on load
  - [ ] Test persistence across browser refresh

- [ ] Task 10: Implement time calculation accuracy (AC: 10)
  - [ ] Use Date objects for all time calculations
  - [ ] Calculate duration: endTime - startTime (in milliseconds)
  - [ ] Convert to minutes: Math.floor(ms / 1000 / 60)
  - [ ] Avoid floating point errors (use integer math where possible)
  - [ ] Test with various durations (seconds, minutes, hours)
  - [ ] Ensure no drift over long periods (test with 24+ hour timer)

- [ ] Task 11: Unit tests for timeUtils (AC: 2, 9, 10)
  - [ ] Create `tests/unit/utils/timeUtils.test.ts`
  - [ ] Test formatDuration with various inputs:
    - [ ] 0 minutes → "0m"
    - [ ] 30 minutes → "30m"
    - [ ] 60 minutes → "1h"
    - [ ] 90 minutes → "1h 30m"
    - [ ] 120 minutes → "2h"
    - [ ] 150 minutes → "2h 30m"
    - [ ] Large durations (1000+ minutes)
  - [ ] Test edge cases and rounding

- [ ] Task 12: Unit tests for TimerDisplay component (AC: 1, 2, 3, 4, 8, 9)
  - [ ] Create `tests/unit/components/timer/TimerDisplay.test.tsx`
  - [ ] Test rendering elapsed time when timer active
  - [ ] Test rendering total time when timer stopped
  - [ ] Test time formatting (human-readable format)
  - [ ] Test loading state
  - [ ] Test error state
  - [ ] Test accessibility (ARIA labels)
  - [ ] Mock TimerContext and TimeEntryRepository

- [ ] Task 13: Unit tests for TimerContext elapsed time (AC: 1, 3, 10)
  - [ ] Update `tests/unit/contexts/TimerContext.test.tsx`
  - [ ] Test elapsed time calculation
  - [ ] Test elapsed time updates every second
  - [ ] Test elapsed time stops updating when timer stops
  - [ ] Test elapsed time accuracy (no drift)
  - [ ] Test getElapsedTime() method
  - [ ] Mock timers (jest.useFakeTimers)

- [ ] Task 14: Integration tests for time display workflow (AC: 1-10)
  - [ ] Create `tests/integration/TimeDisplayWorkflow.test.tsx`
  - [ ] Test complete workflow: start timer → see elapsed time → stop → see total time
  - [ ] Test time display updates every second
  - [ ] Test time format consistency
  - [ ] Test total time calculation from multiple entries
  - [ ] Test persistence across refresh
  - [ ] Test time calculation accuracy
  - [ ] Use React Testing Library

- [ ] Task 15: Performance optimization for time updates (AC: 3, 10)
  - [ ] Ensure setInterval cleanup prevents memory leaks
  - [ ] Use React.memo on TimerDisplay to prevent unnecessary re-renders
  - [ ] Optimize time calculations (cache where possible)
  - [ ] Debounce/throttle if needed (not required for 1-second updates)
  - [ ] Test performance with many task cards (100+)
  - [ ] Ensure smooth 1-second updates without lag

- [ ] Task 16: Code quality and accessibility review (AC: 8, 9)
  - [ ] Ensure all components use TypeScript (no `any`)
  - [ ] Add ARIA labels to TimerDisplay
  - [ ] Ensure semantic HTML structure
  - [ ] Test with screen reader
  - [ ] Ensure time display is readable and accessible
  - [ ] Add JSDoc comments to utilities and components
  - [ ] Run linter and fix any issues
  - [ ] Ensure code follows component template pattern
  - [ ] Verify all acceptance criteria are met

## Dev Notes

### Previous Story Insights
[Source: Story 2.1]

**Key Learnings from Story 2.1:**
- TimerContext is implemented for timer state management
- TimerService handles timer start/stop operations
- TimerStateRepository and TimeEntryRepository are created
- TimerControl component exists and integrates with TaskCard
- Timer state persists to IndexedDB
- TimerContext manages activeTaskId, startTime, elapsedTime, status
- TimerService creates TimeEntry records when timer stops
- TimeEntry duration is stored in minutes

**Important Notes:**
- TimerContext already exists (created in Story 2.1)
- TimeEntryRepository already exists (created in Story 2.1)
- TimerControl already integrated into TaskCard (from Story 2.1)
- Need to add elapsed time calculation and display
- Need to calculate total time from TimeEntry records
- Need to implement real-time updates (every second)

### Tech Stack Requirements
[Source: architecture/common/tech-stack.md]

**Critical Versions:**
- React: ^18.2.0 (already installed)
- TypeScript: ^5.3.0 (already installed)
- Tailwind CSS: ^3.4.0 (already installed)
- Dexie.js: ^3.2.4 (already installed)

**No Additional Dependencies Required:**
- Use native JavaScript Date API for time calculations
- Use React useEffect and setInterval for real-time updates
- Use React Context API for state management (already in use)

### Data Models
[Source: architecture/common/data-models.md#timeentry, Story 2.1]

**TimeEntry Interface (already created in Story 2.1):**
```typescript
interface TimeEntry {
  id: string;
  taskId: string;
  startTime: Date;
  endTime: Date | null;
  duration: number; // in minutes
  isManual: boolean;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}
```

**Key Attributes for Story 2.2:**
- `taskId`: string - Used to query all time entries for a task
- `duration`: number - Sum of all durations gives total time spent (in minutes)
- `startTime`: Date - Used to calculate elapsed time for active timer
- Multiple TimeEntry records per task are supported (AC 7)

**TimerState Interface (from Story 2.1):**
```typescript
interface TimerState {
  taskId: string;
  startTime: Date;
  lastUpdateTime: Date;
  status: 'active' | 'paused' | 'stopped';
}
```

**Key Attributes for Story 2.2:**
- `startTime`: Date - Used to calculate elapsed time for active timer
- `taskId`: string - Used to determine which task has active timer

### Time Formatting Requirements
[Source: Epic 2 AC 2, architecture/common/coding-standards.md]

**Format Rules:**
- Human-readable format: "1h 23m" or "83m"
- Show hours and minutes when hours > 0: "1h 23m", "2h 30m"
- Show minutes only when hours = 0: "83m", "45m"
- Round to nearest minute (no seconds displayed)
- Consistent format across all task cards

**Examples:**
- 0 minutes → "0m"
- 30 minutes → "30m"
- 60 minutes → "1h"
- 90 minutes → "1h 30m"
- 120 minutes → "2h"
- 150 minutes → "2h 30m"
- 83 minutes → "83m"

**Implementation:**
- Create utility function: `formatDuration(minutes: number): string`
- Location: `src/utils/timeUtils.ts`
- Use integer division: hours = Math.floor(minutes / 60), remainingMinutes = minutes % 60

### Real-Time Update Mechanism
[Source: architecture/common/frontend-architecture.md, React patterns]

**Elapsed Time Updates:**
- Use React useEffect with setInterval for 1-second updates
- Calculate elapsed time: currentTime - startTime (in seconds)
- Convert to minutes for display
- Clean up interval on unmount or timer stop
- Use Date.now() for precise time calculations

**Implementation Pattern:**
```typescript
useEffect(() => {
  if (!isActive) return;
  
  const interval = setInterval(() => {
    const elapsed = Math.floor((Date.now() - startTime.getTime()) / 1000);
    setElapsedTime(elapsed);
  }, 1000);
  
  return () => clearInterval(interval);
}, [isActive, startTime]);
```

**Performance Considerations:**
- Only update when timer is active (don't run interval when idle)
- Use React.memo on TimerDisplay to prevent unnecessary re-renders
- Optimize calculations (cache where possible)
- Ensure cleanup prevents memory leaks

### Total Time Calculation
[Source: architecture/common/data-models.md#timeentry, Story 2.1]

**Calculation Logic:**
- Query all TimeEntry records for a task (via taskId)
- Sum all duration values (already in minutes)
- Return total in minutes
- Format using formatDuration utility

**Implementation:**
- Add method to TimeEntryRepository: `getTotalTimeForTask(taskId: string): Promise<number>`
- Query: `db.timeEntries.where('taskId').equals(taskId).toArray()`
- Sum: `entries.reduce((sum, entry) => sum + entry.duration, 0)`
- Return total in minutes

**Caching Strategy:**
- Cache total time calculation to avoid repeated queries
- Invalidate cache when new time entry is created
- Update cache when timer stops (new TimeEntry created)

### Component Architecture
[Source: architecture/common/frontend-architecture.md#component-architecture]

**TimerDisplay Component:**
- Location: `src/components/timer/TimerDisplay.tsx`
- Props: `taskId: string`, `displayMode?: 'elapsed' | 'total'`
- Uses: TimerContext (for elapsed time), TimeEntryRepository (for total time)
- Styling: Tailwind CSS (subtle, doesn't dominate card)
- Accessibility: ARIA labels, semantic HTML

**Component Template Pattern:**
```typescript
import React, { useEffect, useState } from 'react';
import { useTimerContext } from '@/contexts/TimerContext';
import { timeEntryRepository } from '@/services/data/repositories/TimeEntryRepository';
import { formatDuration } from '@/utils/timeUtils';

interface TimerDisplayProps {
  taskId: string;
  displayMode?: 'elapsed' | 'total';
}

export const TimerDisplay: React.FC<TimerDisplayProps> = ({ taskId, displayMode = 'auto' }) => {
  const { activeTaskId, getElapsedTime } = useTimerContext();
  const [totalTime, setTotalTime] = useState<number>(0);
  const [loading, setLoading] = useState(true);
  
  const isActive = activeTaskId === taskId;
  const elapsedTime = isActive ? getElapsedTime(taskId) : 0;
  
  // Load total time on mount
  useEffect(() => {
    // Implementation
  }, [taskId]);
  
  // Component logic
  
  return (
    <div className="..." aria-label="Time spent">
      {/* JSX */}
    </div>
  );
};
```

### TimerContext Updates
[Source: Story 2.1, architecture/common/frontend-architecture.md]

**Required Updates to TimerContext:**
- Add elapsedTime state (in seconds)
- Add useEffect to update elapsedTime every second when timer is active
- Add getElapsedTime(taskId: string): number method
- Expose elapsedTime in context value
- Ensure cleanup of interval on unmount

**TimerContext State Structure (updated):**
```typescript
interface TimerContextState {
  activeTaskId: string | null;
  startTime: Date | null;
  elapsedTime: number; // in seconds
  status: 'idle' | 'active' | 'paused';
  getElapsedTime: (taskId: string) => number;
}
```

**Implementation Notes:**
- Calculate elapsed time: Math.floor((Date.now() - startTime.getTime()) / 1000)
- Update every second using setInterval
- Return 0 when timer is not active for the task
- Clean up interval when timer stops or component unmounts

### Repository Pattern
[Source: Story 2.1, architecture/common/coding-standards.md]

**TimeEntryRepository Updates:**
- Add method: `getTotalTimeForTask(taskId: string): Promise<number>`
- Query all time entries for task: `db.timeEntries.where('taskId').equals(taskId).toArray()`
- Sum durations: `entries.reduce((sum, entry) => sum + entry.duration, 0)`
- Return total in minutes
- Handle case where no entries exist (return 0)
- Follow async/await pattern
- Add error handling (try/catch)

**Method Signature:**
```typescript
async getTotalTimeForTask(taskId: string): Promise<number> {
  // Implementation
}
```

### File Locations
[Source: architecture/unified-project-structure.md, Story 2.1]

**New Files to Create:**
- `src/utils/timeUtils.ts` - Time formatting utilities
- `src/components/timer/TimerDisplay.tsx` - Time display component
- `tests/unit/utils/timeUtils.test.ts` - Time utility tests
- `tests/unit/components/timer/TimerDisplay.test.tsx` - TimerDisplay tests
- `tests/integration/TimeDisplayWorkflow.test.tsx` - Integration tests

**Files to Modify:**
- `src/contexts/TimerContext.tsx` - Add elapsed time calculation and updates
- `src/services/data/repositories/TimeEntryRepository.ts` - Add getTotalTimeForTask method
- `src/components/kanban/TaskCard.tsx` - Add TimerDisplay component
- `tests/unit/contexts/TimerContext.test.tsx` - Add elapsed time tests

### Testing Requirements
[Source: architecture/common/testing-strategy.md]

**Unit Tests:**
- timeUtils: Test formatDuration with various inputs, edge cases
- TimerDisplay: Test rendering, time formatting, loading/error states
- TimerContext: Test elapsed time calculation, updates, cleanup

**Integration Tests:**
- Complete workflow: start timer → see elapsed time → stop → see total time
- Time display updates every second
- Time format consistency
- Total time calculation from multiple entries
- Persistence across refresh

**Test Organization:**
- Unit tests: `tests/unit/utils/`, `tests/unit/components/timer/`, `tests/unit/contexts/`
- Integration tests: `tests/integration/TimeDisplayWorkflow.test.tsx`
- Use Jest + React Testing Library
- Mock TimerContext and TimeEntryRepository
- Use jest.useFakeTimers for time-based tests

**Test Examples:**
```typescript
// timeUtils test example
describe('formatDuration', () => {
  it('formats 90 minutes as "1h 30m"', () => {
    expect(formatDuration(90)).toBe('1h 30m');
  });
  
  it('formats 83 minutes as "83m"', () => {
    expect(formatDuration(83)).toBe('83m');
  });
});

// TimerDisplay test example
describe('TimerDisplay', () => {
  it('displays elapsed time when timer active', () => {
    // Test implementation
  });
  
  it('displays total time when timer stopped', async () => {
    // Test implementation
  });
});
```

### Accessibility Requirements
[Source: architecture/common/accessibility-implementation.md]

**WCAG 2.1 AA Compliance:**
- ARIA labels: TimerDisplay must have proper ARIA label
- Screen reader support: Time should be announced clearly
- Visual indicators: Time display should be readable (sufficient contrast)
- Semantic HTML: Use appropriate HTML elements

**Accessibility Checklist:**
- [ ] TimerDisplay has ARIA label (e.g., "Time spent: 1h 23m")
- [ ] Time is announced by screen readers
- [ ] Time display has sufficient contrast
- [ ] Time format is clear and readable

### Coding Standards
[Source: architecture/common/coding-standards.md]

**Critical Rules:**
- Type Safety: Always use TypeScript types/interfaces, avoid `any`
- Component Organization: One component per file, co-locate related components
- State Management: Use Context API, avoid prop drilling beyond 2 levels
- Data Access: Always use repository pattern, never access IndexedDB directly from components
- Error Handling: All async operations must have try/catch, use Error Boundaries for component errors
- Performance: Use React.memo, useMemo, useCallback appropriately, avoid unnecessary re-renders
- Cleanup: Always clean up intervals/timeouts in useEffect cleanup

**Naming Conventions:**
- Components: PascalCase (e.g., `TimerDisplay.tsx`)
- Utilities: camelCase (e.g., `timeUtils.ts`, `formatDuration`)
- Functions: camelCase (e.g., `getTotalTimeForTask`)

### Project Structure Notes
[Source: architecture/unified-project-structure.md]

**Component Organization:**
- Timer components go in `src/components/timer/` directory
- Timer utilities go in `src/utils/` directory
- Timer context updates go in `src/contexts/` directory
- Timer repository updates go in `src/services/data/repositories/` directory

**Integration Points:**
- TimerDisplay integrates into existing TaskCard component (from Story 1.5)
- TimerDisplay uses TimerContext (from Story 2.1)
- TimerDisplay uses TimeEntryRepository (from Story 2.1)
- TimerContext updates build on existing implementation (from Story 2.1)

### Performance Considerations
[Source: architecture/common/coding-standards.md]

**Optimization Strategies:**
- Use React.memo on TimerDisplay to prevent unnecessary re-renders
- Clean up setInterval in useEffect cleanup
- Cache total time calculation (avoid repeated queries)
- Only update elapsed time when timer is active
- Use useMemo for expensive calculations
- Test performance with many task cards (100+)

**Memory Leak Prevention:**
- Always clean up intervals in useEffect cleanup
- Clear interval when timer stops
- Clear interval when component unmounts
- Test for memory leaks with long-running timers

### Testing
[Source: architecture/common/testing-strategy.md]

**Test File Location:**
- Unit tests: `tests/unit/utils/`, `tests/unit/components/timer/`, `tests/unit/contexts/`
- Integration tests: `tests/integration/`

**Test Standards:**
- Use Jest ^29.7.0 for unit testing
- Use React Testing Library ^14.0.0 for component testing
- Use jest.useFakeTimers for time-based tests
- Follow Arrange-Act-Assert pattern
- Mock TimerContext and TimeEntryRepository
- Aim for 80%+ code coverage

**Specific Test Requirements:**
- Test time formatting with various inputs
- Test elapsed time calculation accuracy
- Test real-time updates (1-second intervals)
- Test total time calculation from multiple entries
- Test persistence across refresh
- Test performance with many task cards
- Test edge cases (0 minutes, large durations, rapid start/stop)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-19 | 1.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA Agent_
