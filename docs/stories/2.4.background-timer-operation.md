# Story 2.4: Background Timer Operation

## Status
Draft

## Story
**As a** user,
**I want** the timer to continue running when I switch browser tabs or minimize the window,
**so that** I can track time accurately even when working in other applications.

## Acceptance Criteria

1. Timer continues running when browser tab is not active (using Web Workers or Service Workers)
2. Timer state persists and resumes correctly when returning to application
3. Elapsed time calculation accounts for time when tab was inactive
4. Background timer operation works across browser tab switches
5. Timer accuracy is maintained within acceptable limits (handles browser throttling)
6. Visual indicator shows timer is running even when tab is inactive (browser tab title or badge)
7. Timer stops gracefully if browser is closed (saves current session time)
8. Background operation doesn't significantly impact browser performance
9. Timer state is recoverable if application crashes (saves progress periodically)
10. User receives notification/indicator when returning to tab with active timer

## Tasks / Subtasks

- [ ] Task 1: Create Service Worker timer handler (AC: 1, 2, 3, 4, 5)
  - [ ] Create or update `public/sw.js` (Service Worker file)
  - [ ] Import Dexie.js for IndexedDB access in Service Worker
  - [ ] Set up message listener for timer start/stop messages
  - [ ] Implement timer interval in Service Worker (runs every 30-60 seconds)
  - [ ] Update TimerState in IndexedDB periodically (lastUpdateTime)
  - [ ] Handle timer state persistence in Service Worker
  - [ ] Calculate elapsed time based on stored startTime
  - [ ] Handle browser throttling gracefully (Service Workers have higher priority)

- [ ] Task 2: Implement Service Worker message handling (AC: 1, 2, 3)
  - [ ] Handle TIMER_START message from main thread
  - [ ] Handle TIMER_STOP message from main thread
  - [ ] Store timer state in IndexedDB on start
  - [ ] Delete timer state from IndexedDB on stop
  - [ ] Send timer state updates back to main thread when tab becomes active
  - [ ] Handle cross-tab synchronization (multiple tabs)

- [ ] Task 3: Update TimerService to communicate with Service Worker (AC: 1, 2, 3, 4)
  - [ ] Update `src/services/TimerService.ts`
  - [ ] Send TIMER_START message to Service Worker on startTimer()
  - [ ] Send TIMER_STOP message to Service Worker on stopTimer()
  - [ ] Check for Service Worker availability before sending messages
  - [ ] Handle case where Service Worker is not available (fallback to main thread only)
  - [ ] Add error handling for Service Worker communication failures

- [ ] Task 4: Implement tab visibility detection (AC: 1, 2, 3, 4)
  - [ ] Create `src/hooks/usePageVisibility.ts` hook
  - [ ] Use Page Visibility API (document.hidden, visibilitychange event)
  - [ ] Detect when tab becomes inactive
  - [ ] Detect when tab becomes active
  - [ ] Notify TimerContext when visibility changes
  - [ ] Handle edge cases (tab switching, window minimize/maximize)

- [ ] Task 5: Implement timer state synchronization on tab activation (AC: 2, 3, 10)
  - [ ] Update TimerContext to listen for tab visibility changes
  - [ ] When tab becomes active, request timer state from Service Worker
  - [ ] Calculate precise elapsed time: currentTime - startTime (from IndexedDB)
  - [ ] Update TimerContext state with accurate elapsed time
  - [ ] Resume timer updates in main thread
  - [ ] Show notification/indicator that timer was running in background

- [ ] Task 6: Implement periodic timer state saves (AC: 9)
  - [ ] Update TimerContext to save timer state periodically (every 30-60 seconds)
  - [ ] Save TimerState to IndexedDB with current lastUpdateTime
  - [ ] Ensure state is saved even if app crashes
  - [ ] Handle errors gracefully (don't interrupt timer if save fails)
  - [ ] Optimize write frequency to balance accuracy and performance

- [ ] Task 7: Implement browser tab title/badge updates (AC: 6)
  - [ ] Create `src/utils/tabTitle.ts` utility
  - [ ] Update document.title when timer is active (e.g., "⏱ Task Name - App Name")
  - [ ] Update document.title when timer stops (remove timer indicator)
  - [ ] Use Badge API if available (navigator.setAppBadge)
  - [ ] Handle case where Badge API is not supported (fallback to title only)
  - [ ] Clear badge when timer stops

- [ ] Task 8: Implement beforeunload handler for graceful shutdown (AC: 7)
  - [ ] Add beforeunload event listener in TimerContext
  - [ ] When browser is closing, save current timer state to IndexedDB
  - [ ] Calculate final elapsed time before closing
  - [ ] Optionally create TimeEntry if timer was running (or save state for recovery)
  - [ ] Handle case where user cancels close (don't create duplicate entry)
  - [ ] Test graceful shutdown behavior

- [ ] Task 9: Implement timer recovery on app load (AC: 2, 9)
  - [ ] Update TimerContext to check for active timer state on mount
  - [ ] Query IndexedDB for TimerState with status 'active'
  - [ ] If active timer found, restore timer state
  - [ ] Calculate elapsed time: currentTime - storedStartTime
  - [ ] Resume timer display and updates
  - [ ] Show notification that timer was recovered
  - [ ] Handle edge cases (very old timer state, corrupted state)

- [ ] Task 10: Optimize Service Worker timer interval (AC: 5, 8)
  - [ ] Set Service Worker interval to 30-60 seconds (not every second)
  - [ ] Update IndexedDB only when necessary (not on every interval)
  - [ ] Use efficient IndexedDB operations (batch updates if possible)
  - [ ] Monitor Service Worker performance (avoid excessive writes)
  - [ ] Ensure timer accuracy despite longer intervals (calculate from startTime)

- [ ] Task 11: Implement cross-tab timer synchronization (AC: 4)
  - [ ] Use BroadcastChannel API or IndexedDB events for cross-tab communication
  - [ ] When timer starts in one tab, notify other tabs
  - [ ] When timer stops in one tab, notify other tabs
  - [ ] Ensure only one timer can be active across all tabs
  - [ ] Update UI in all tabs when timer state changes
  - [ ] Handle race conditions (multiple tabs starting timer simultaneously)

- [ ] Task 12: Add notification/indicator for background timer (AC: 10)
  - [ ] Create `src/components/timer/BackgroundTimerIndicator.tsx` component
  - [ ] Display notification when returning to tab with active timer
  - [ ] Show message: "Timer was running in background for X minutes"
  - [ ] Style notification with Tailwind CSS (toast or banner)
  - [ ] Auto-dismiss after few seconds or allow manual dismiss
  - [ ] Ensure notification is accessible (ARIA live region)

- [ ] Task 13: Handle Service Worker unavailability (AC: 1, 2, 3)
  - [ ] Detect when Service Worker is not available (not registered, not supported)
  - [ ] Fallback to main thread timer only (degraded mode)
  - [ ] Show warning to user if Service Worker unavailable (optional)
  - [ ] Ensure timer still works without Service Worker (basic functionality)
  - [ ] Document limitations when Service Worker unavailable

- [ ] Task 14: Add Dexie.js to Service Worker (AC: 1, 2, 3, 9)
  - [ ] Import Dexie.js in Service Worker context
  - [ ] Create database instance in Service Worker (same schema as main thread)
  - [ ] Ensure Service Worker can access TimerState table
  - [ ] Ensure Service Worker can access TimeEntry table (for future use)
  - [ ] Handle IndexedDB access errors in Service Worker
  - [ ] Test Service Worker IndexedDB operations

- [ ] Task 15: Unit tests for Service Worker timer handler (AC: 1, 2, 3, 5)
  - [ ] Create `tests/unit/service-worker/timer-handler.test.ts`
  - [ ] Test TIMER_START message handling
  - [ ] Test TIMER_STOP message handling
  - [ ] Test timer interval execution
  - [ ] Test IndexedDB updates
  - [ ] Mock Service Worker environment
  - [ ] Mock IndexedDB operations

- [ ] Task 16: Unit tests for TimerService Service Worker integration (AC: 1, 2, 3, 4)
  - [ ] Update `tests/unit/services/TimerService.test.ts`
  - [ ] Test Service Worker message sending
  - [ ] Test fallback when Service Worker unavailable
  - [ ] Test error handling for Service Worker communication
  - [ ] Mock Service Worker and navigator.serviceWorker

- [ ] Task 17: Unit tests for page visibility hook (AC: 1, 2, 3, 4)
  - [ ] Create `tests/unit/hooks/usePageVisibility.test.ts`
  - [ ] Test visibility change detection
  - [ ] Test tab activation/deactivation
  - [ ] Mock Page Visibility API
  - [ ] Test edge cases

- [ ] Task 18: Integration tests for background timer workflow (AC: 1-10)
  - [ ] Create `tests/integration/BackgroundTimerWorkflow.test.tsx`
  - [ ] Test timer continues when tab becomes inactive
  - [ ] Test timer resumes correctly when tab becomes active
  - [ ] Test elapsed time calculation accounts for inactive time
  - [ ] Test timer recovery on app load
  - [ ] Test graceful shutdown
  - [ ] Test cross-tab synchronization
  - [ ] Use Playwright or similar for tab switching simulation

- [ ] Task 19: Performance testing and optimization (AC: 5, 8)
  - [ ] Test timer accuracy over extended periods (hours)
  - [ ] Monitor Service Worker performance (CPU, memory)
  - [ ] Test with multiple tabs open
  - [ ] Test with browser throttling enabled
  - [ ] Optimize IndexedDB write frequency
  - [ ] Ensure no significant performance impact

- [ ] Task 20: Code quality and error handling review (AC: 1-10)
  - [ ] Ensure all Service Worker code has error handling
  - [ ] Add comprehensive error logging
  - [ ] Handle edge cases (Service Worker termination, IndexedDB errors)
  - [ ] Ensure graceful degradation when Service Worker unavailable
  - [ ] Add JSDoc comments to Service Worker code
  - [ ] Run linter and fix any issues
  - [ ] Verify all acceptance criteria are met

## Dev Notes

### Previous Story Insights
[Source: Story 1.3, Story 2.1, Story 2.2]

**Key Learnings from Story 1.3:**
- Service Worker is registered using Workbox ^7.0.0
- Service Worker file is at `/sw.js` (generated by vite-plugin-pwa)
- Service Worker registration utilities exist in `src/utils/serviceWorker.ts`
- Service Worker is already set up for asset caching
- IndexedDB is accessible from Service Worker context

**Key Learnings from Story 2.1:**
- TimerContext manages timer state (activeTaskId, startTime, elapsedTime, status)
- TimerService handles timer start/stop operations
- TimerStateRepository manages TimerState persistence
- TimerState is stored in IndexedDB with taskId, startTime, lastUpdateTime, status

**Key Learnings from Story 2.2:**
- TimerDisplay shows elapsed time and total time
- Elapsed time updates every second in main thread
- formatDuration utility formats time as "1h 23m" or "83m"

**Important Notes:**
- Service Worker infrastructure exists (from Story 1.3)
- TimerContext and TimerService exist (from Story 2.1)
- TimerStateRepository exists (from Story 2.1)
- Need to extend Service Worker to handle timer operations
- Need to implement tab visibility detection
- Need to implement cross-tab synchronization

### Tech Stack Requirements
[Source: architecture/common/tech-stack.md, Story 1.3]

**Critical Versions:**
- Workbox: ^7.0.0 (already installed)
- Dexie.js: ^3.2.4 (already installed, needs to work in Service Worker)
- React: ^18.2.0 (already installed)
- TypeScript: ^5.3.0 (already installed)

**Service Worker APIs:**
- Service Worker API (browser-native)
- IndexedDB API (accessible from Service Worker)
- BroadcastChannel API (for cross-tab communication, optional)
- Badge API (for tab badge, optional, newer browsers)
- Page Visibility API (for tab visibility detection)

### Service Worker Architecture
[Source: architecture/high-level-architecture.md#service-worker-background-timer-implementation-details]

**Service Worker Timer Pattern:**
1. **Main Thread Timer:** When tab is active, React app manages timer with setInterval
2. **Service Worker Timer:** When tab is inactive, Service Worker takes over:
   - Receives timer start/stop messages via postMessage
   - Uses setInterval in Service Worker context (not subject to tab throttling)
   - Stores timer state in IndexedDB for persistence
   - Calculates elapsed time based on stored start timestamp
3. **State Synchronization:** Timer state stored in IndexedDB, accessible from both contexts

**Implementation Details:**
- Service Worker interval runs every 30-60 seconds (not every second for efficiency)
- Periodic updates to IndexedDB store current elapsed time (lastUpdateTime)
- On tab reactivation, calculates precise elapsed time from stored start timestamp
- Handles browser throttling gracefully (Service Workers have higher priority)

**Browser Limitations:**
- Some browsers throttle Service Worker execution when system is idle
- Timer accuracy may degrade slightly during extended inactivity
- Start/stop timestamps ensure accurate total time calculation despite throttling

### Service Worker Message Protocol
[Source: architecture/core-workflows.md#workflow-4-background-timer-operation]

**Message Types:**
- `TIMER_START`: { type: 'TIMER_START', taskId: string, startTime: string (ISO) }
- `TIMER_STOP`: { type: 'TIMER_STOP', taskId: string }
- `TIMER_STATE_REQUEST`: { type: 'TIMER_STATE_REQUEST' }
- `TIMER_STATE_RESPONSE`: { type: 'TIMER_STATE_RESPONSE', state: TimerState | null }

**Message Flow:**
1. Main thread sends TIMER_START to Service Worker
2. Service Worker stores timer state in IndexedDB
3. Service Worker starts interval timer (updates IndexedDB periodically)
4. When tab becomes active, main thread sends TIMER_STATE_REQUEST
5. Service Worker responds with TIMER_STATE_RESPONSE
6. Main thread calculates precise elapsed time and updates UI

### IndexedDB in Service Worker
[Source: architecture/common/data-storage-architecture.md, Story 2.1]

**Dexie.js in Service Worker:**
- Service Worker can access IndexedDB using Dexie.js
- Need to import Dexie.js in Service Worker context
- Create database instance in Service Worker (same schema as main thread)
- Service Worker and main thread share same IndexedDB database

**Database Access:**
- Service Worker can read/write TimerState table
- Service Worker can read/write TimeEntry table (for future use)
- Both contexts use same database instance (shared storage)

**Implementation:**
```typescript
// In Service Worker (sw.js)
import Dexie from 'dexie';

// Create database instance (same schema as main thread)
const db = new Dexie('TimeTrackingDB');
db.version(1).stores({
  timerState: 'taskId',
  timeEntries: 'id, taskId, startTime, endTime, [taskId+startTime]',
  // ... other tables
});
```

### Tab Visibility Detection
[Source: Page Visibility API, architecture patterns]

**Page Visibility API:**
- `document.hidden`: Boolean indicating if page is hidden
- `document.visibilityState`: 'visible' | 'hidden' | 'prerender'
- `visibilitychange` event: Fired when visibility changes

**Implementation Pattern:**
```typescript
useEffect(() => {
  const handleVisibilityChange = () => {
    if (document.hidden) {
      // Tab became inactive - Service Worker takes over
    } else {
      // Tab became active - request timer state from Service Worker
    }
  };
  
  document.addEventListener('visibilitychange', handleVisibilityChange);
  return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
}, []);
```

### Timer State Persistence
[Source: Story 2.1, architecture/common/data-models.md#timerstate]

**TimerState Model:**
```typescript
interface TimerState {
  taskId: string;
  startTime: Date;
  lastUpdateTime: Date;
  status: 'active' | 'paused' | 'stopped';
}
```

**Persistence Strategy:**
- Save timer state to IndexedDB immediately on start
- Update lastUpdateTime periodically (every 30-60 seconds)
- Save timer state on beforeunload (browser close)
- Load timer state on app mount (recovery)

**Recovery Logic:**
- On app load, check IndexedDB for active timer state
- If found, calculate elapsed time: currentTime - startTime
- Resume timer display and updates
- Show notification that timer was recovered

### Browser Tab Title/Badge Updates
[Source: Epic 2 AC 6, Badge API]

**Tab Title Updates:**
- Update `document.title` when timer is active
- Format: "⏱ Task Name - App Name" or "⏱ 1h 23m - App Name"
- Restore original title when timer stops

**Badge API (Optional):**
- Use `navigator.setAppBadge(count)` if available
- Show badge count (elapsed minutes or just indicator)
- Clear badge when timer stops: `navigator.clearAppBadge()`
- Fallback to title only if Badge API not supported

**Implementation:**
```typescript
// Update tab title
document.title = isActive ? `⏱ ${taskTitle} - App Name` : 'App Name';

// Update badge (if supported)
if ('setAppBadge' in navigator) {
  navigator.setAppBadge(isActive ? 1 : 0);
}
```

### Cross-Tab Synchronization
[Source: architecture/high-level-architecture.md, BroadcastChannel API]

**Synchronization Strategy:**
- Use BroadcastChannel API or IndexedDB events for cross-tab communication
- When timer starts in one tab, notify other tabs
- When timer stops in one tab, notify other tabs
- Ensure only one timer can be active across all tabs

**BroadcastChannel Pattern:**
```typescript
const channel = new BroadcastChannel('timer-sync');

// Send message
channel.postMessage({ type: 'TIMER_START', taskId });

// Listen for messages
channel.onmessage = (event) => {
  // Handle timer state change from other tab
};
```

### Performance Considerations
[Source: architecture/high-level-architecture.md, Epic 2 AC 8]

**Optimization Strategies:**
- Service Worker interval: 30-60 seconds (not every second)
- Update IndexedDB only when necessary (not on every interval)
- Use efficient IndexedDB operations (batch updates if possible)
- Monitor Service Worker performance (CPU, memory)
- Ensure no significant performance impact

**Browser Throttling:**
- Service Workers have higher priority than inactive tabs
- Timer accuracy maintained despite throttling (calculate from startTime)
- Handle extended inactivity gracefully

### Error Handling
[Source: architecture/common/error-handling-strategy.md]

**Service Worker Error Handling:**
- Handle Service Worker unavailability gracefully
- Fallback to main thread timer only (degraded mode)
- Handle IndexedDB errors in Service Worker
- Handle message sending failures
- Log errors for debugging

**Recovery Strategies:**
- If Service Worker fails, timer state persists in IndexedDB
- On next app load, recover timer state from IndexedDB
- Handle corrupted timer state gracefully

### File Locations
[Source: architecture/unified-project-structure.md, Story 1.3]

**New Files to Create:**
- `public/sw.js` or update existing Service Worker file (timer handler)
- `src/hooks/usePageVisibility.ts` - Page visibility detection hook
- `src/utils/tabTitle.ts` - Tab title/badge update utility
- `src/components/timer/BackgroundTimerIndicator.tsx` - Background timer notification
- `tests/unit/service-worker/timer-handler.test.ts` - Service Worker tests
- `tests/unit/hooks/usePageVisibility.test.ts` - Visibility hook tests
- `tests/integration/BackgroundTimerWorkflow.test.tsx` - Integration tests

**Files to Modify:**
- `src/services/TimerService.ts` - Add Service Worker communication
- `src/contexts/TimerContext.tsx` - Add tab visibility handling, recovery logic
- `src/services/data/repositories/TimerStateRepository.ts` - Ensure works in Service Worker
- `tests/unit/services/TimerService.test.ts` - Add Service Worker tests

### Testing Requirements
[Source: architecture/common/testing-strategy.md]

**Unit Tests:**
- Service Worker timer handler: Message handling, interval execution, IndexedDB updates
- TimerService: Service Worker communication, fallback behavior
- Page visibility hook: Visibility change detection
- Tab title utility: Title/badge updates

**Integration Tests:**
- Complete workflow: Start timer → Switch tab → Return → Verify elapsed time
- Timer recovery on app load
- Cross-tab synchronization
- Graceful shutdown
- Use Playwright or similar for tab switching simulation

**Test Organization:**
- Unit tests: `tests/unit/service-worker/`, `tests/unit/hooks/`, `tests/unit/services/`
- Integration tests: `tests/integration/BackgroundTimerWorkflow.test.tsx`
- Use Jest for unit tests, Playwright for integration tests
- Mock Service Worker environment and Page Visibility API

**Test Examples:**
```typescript
// Service Worker test example
describe('Service Worker Timer Handler', () => {
  it('handles TIMER_START message', async () => {
    // Test implementation
  });
  
  it('updates timer state periodically', async () => {
    // Test implementation
  });
});
```

### Accessibility Requirements
[Source: architecture/common/accessibility-implementation.md]

**Background Timer Indicators:**
- Tab title updates are accessible (screen readers can announce)
- Badge updates are visual (no screen reader impact)
- Background timer notification is accessible (ARIA live region)
- Timer recovery notification is accessible

**Accessibility Checklist:**
- [ ] Tab title changes are announced (if supported)
- [ ] Background timer notification uses ARIA live region
- [ ] Timer recovery notification is accessible
- [ ] All notifications have proper ARIA labels

### Coding Standards
[Source: architecture/common/coding-standards.md]

**Critical Rules:**
- Type Safety: Always use TypeScript types/interfaces, avoid `any`
- Error Handling: All Service Worker operations must have try/catch
- Performance: Optimize Service Worker operations (minimize IndexedDB writes)
- Graceful Degradation: Handle Service Worker unavailability gracefully
- Logging: Add comprehensive error logging for debugging

**Service Worker Specific:**
- Service Worker code must be self-contained (no DOM access)
- Use postMessage for communication with main thread
- Handle Service Worker lifecycle events (install, activate, message)
- Ensure Service Worker code is efficient (runs in background)

### Project Structure Notes
[Source: architecture/unified-project-structure.md]

**Service Worker Organization:**
- Service Worker file: `public/sw.js` (generated by vite-plugin-pwa or custom)
- Service Worker utilities: Can be in `src/utils/` but need to be importable in SW context
- Service Worker tests: `tests/unit/service-worker/`

**Integration Points:**
- TimerService communicates with Service Worker
- TimerContext handles tab visibility and recovery
- Service Worker shares IndexedDB with main thread
- Both contexts use same TimerStateRepository pattern

### Testing
[Source: architecture/common/testing-strategy.md]

**Test File Location:**
- Unit tests: `tests/unit/service-worker/`, `tests/unit/hooks/`, `tests/unit/services/`
- Integration tests: `tests/integration/`

**Test Standards:**
- Use Jest ^29.7.0 for unit testing
- Use Playwright ^1.40.0 for integration/E2E testing (tab switching)
- Mock Service Worker environment
- Mock Page Visibility API
- Test error scenarios (Service Worker unavailable, IndexedDB errors)

**Specific Test Requirements:**
- Test timer continues when tab inactive
- Test timer resumes correctly when tab active
- Test elapsed time calculation accuracy
- Test timer recovery on app load
- Test graceful shutdown
- Test cross-tab synchronization
- Test performance (no significant impact)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-19 | 1.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA Agent_
