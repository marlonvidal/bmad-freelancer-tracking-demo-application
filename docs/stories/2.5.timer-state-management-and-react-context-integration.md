# Story 2.5: Timer State Management and React Context Integration

## Status
Draft

## Story
**As a** developer,
**I want** timer state managed through React Context,
**so that** timer functionality is accessible throughout the application and state updates trigger UI updates.

## Acceptance Criteria

1. Timer Context Provider manages active timer state (current task ID, start time, elapsed time)
2. Timer Context provides functions: startTimer, stopTimer, pauseTimer (if implemented)
3. Timer state updates trigger re-renders of affected task cards
4. Only one timer can be active at a time (enforced by Context)
5. Timer state persists to IndexedDB on start/stop operations
6. Timer Context integrates with existing task/board Context
7. Timer state is testable via unit tests with mock Context
8. Timer operations are debounced/throttled appropriately to prevent excessive updates
9. Timer Context handles edge cases (multiple rapid start/stop, browser refresh during timer)
10. Timer state management doesn't cause unnecessary re-renders of unrelated components

## Tasks / Subtasks

- [ ] Task 1: Review and refine TimerContext implementation (AC: 1, 2, 4, 5)
  - [ ] Review existing TimerContext from Story 2.1
  - [ ] Ensure TimerContext follows same patterns as TaskContext/ColumnContext
  - [ ] Verify state structure: activeTaskId, startTime, elapsedTime, status
  - [ ] Verify methods: startTimer, stopTimer, getElapsedTime
  - [ ] Ensure single active timer enforcement is robust
  - [ ] Ensure IndexedDB persistence on start/stop
  - [ ] Add pauseTimer method (if not already implemented, mark as optional)

- [ ] Task 2: Optimize TimerContext value object (AC: 10)
  - [ ] Use useMemo to memoize context value object
  - [ ] Ensure value object only changes when state actually changes
  - [ ] Split context value into stable and changing parts if needed
  - [ ] Prevent unnecessary re-renders of consumers
  - [ ] Follow same pattern as TaskContext/ColumnContext

- [ ] Task 3: Implement debouncing/throttling for timer updates (AC: 8)
  - [ ] Throttle elapsed time updates (update every second, not more frequently)
  - [ ] Debounce rapid start/stop operations (prevent race conditions)
  - [ ] Use useCallback for timer functions to prevent recreation
  - [ ] Ensure debouncing doesn't affect user experience
  - [ ] Test with rapid clicks (start/stop rapidly)

- [ ] Task 4: Optimize elapsed time calculation (AC: 1, 8, 10)
  - [ ] Use useMemo for elapsed time calculation
  - [ ] Only recalculate when startTime or current time changes
  - [ ] Use requestAnimationFrame or setInterval efficiently
  - [ ] Clean up intervals properly on unmount
  - [ ] Prevent unnecessary calculations

- [ ] Task 5: Integrate TimerContext with TaskContext (AC: 6)
  - [ ] Ensure TimerContext can access TaskContext if needed
  - [ ] Create shared hook or utility if both contexts needed together
  - [ ] Ensure timer operations don't interfere with task operations
  - [ ] Test integration scenarios
  - [ ] Document integration patterns

- [ ] Task 6: Ensure proper Context provider nesting (AC: 6)
  - [ ] Review App.tsx provider structure
  - [ ] Ensure TimerProvider is properly nested with TaskProvider/ColumnProvider
  - [ ] Verify provider order doesn't cause issues
  - [ ] Test context access from nested components
  - [ ] Follow same pattern as existing providers

- [ ] Task 7: Add edge case handling (AC: 9)
  - [ ] Handle multiple rapid start/stop calls (debounce or queue)
  - [ ] Handle browser refresh during active timer (recovery logic)
  - [ ] Handle timer start when another timer is active (stop previous)
  - [ ] Handle invalid taskId (task deleted while timer running)
  - [ ] Handle IndexedDB errors gracefully
  - [ ] Add comprehensive error handling

- [ ] Task 8: Implement selective re-rendering (AC: 3, 10)
  - [ ] Ensure only task cards with active timer re-render on elapsed time updates
  - [ ] Use React.memo on TaskCard to prevent unnecessary re-renders
  - [ ] Use useMemo in TimerDisplay to prevent unnecessary recalculations
  - [ ] Split timer state if needed (active timer state vs. elapsed time)
  - [ ] Test re-render behavior with React DevTools Profiler

- [ ] Task 9: Add comprehensive error boundaries (AC: 9)
  - [ ] Wrap TimerContext operations in try/catch
  - [ ] Provide error state in context value
  - [ ] Handle errors gracefully (don't crash app)
  - [ ] Log errors for debugging
  - [ ] Show user-friendly error messages

- [ ] Task 10: Enhance TimerContext testing (AC: 7)
  - [ ] Review existing TimerContext tests from Story 2.1
  - [ ] Add tests for edge cases (rapid start/stop, browser refresh)
  - [ ] Add tests for debouncing/throttling behavior
  - [ ] Add tests for re-render optimization
  - [ ] Add tests for error handling
  - [ ] Ensure tests follow same patterns as TaskContext/ColumnContext tests

- [ ] Task 11: Add Context value stability checks (AC: 10)
  - [ ] Use React.useMemo for context value
  - [ ] Ensure functions are wrapped in useCallback
  - [ ] Verify value object reference stability
  - [ ] Test with React DevTools to verify no unnecessary re-renders
  - [ ] Compare with TaskContext/ColumnContext patterns

- [ ] Task 12: Implement pauseTimer functionality (AC: 2)
  - [ ] Add pauseTimer method to TimerContext (optional, if not in Story 2.1)
  - [ ] Update TimerState status to 'paused'
  - [ ] Persist paused state to IndexedDB
  - [ ] Handle resume from paused state
  - [ ] Update TimerControl to show pause/resume button
  - [ ] Note: This may be deferred if not in original requirements

- [ ] Task 13: Add timer state validation (AC: 9)
  - [ ] Validate timer state on load (check for corrupted state)
  - [ ] Validate taskId exists before starting timer
  - [ ] Validate startTime is valid Date
  - [ ] Handle invalid timer state gracefully
  - [ ] Reset invalid timer state

- [ ] Task 14: Optimize IndexedDB write operations (AC: 5, 8)
  - [ ] Batch IndexedDB writes if possible
  - [ ] Debounce IndexedDB updates (don't write on every elapsed time update)
  - [ ] Only write when necessary (state actually changed)
  - [ ] Use transactions for multiple writes
  - [ ] Monitor write performance

- [ ] Task 15: Add timer state synchronization helpers (AC: 6)
  - [ ] Create utility functions for timer state synchronization
  - [ ] Ensure timer state syncs with TaskContext when needed
  - [ ] Handle case where task is deleted while timer is active
  - [ ] Handle case where task column changes while timer is active
  - [ ] Test synchronization scenarios

- [ ] Task 16: Performance testing and optimization (AC: 8, 10)
  - [ ] Use React DevTools Profiler to measure re-renders
  - [ ] Test with many task cards (100+)
  - [ ] Measure timer update performance
  - [ ] Optimize based on profiling results
  - [ ] Ensure no performance degradation

- [ ] Task 17: Add comprehensive JSDoc documentation (AC: 1, 2)
  - [ ] Document TimerContext interface
  - [ ] Document all methods with parameters and return types
  - [ ] Document state structure
  - [ ] Document usage examples
  - [ ] Follow same documentation style as TaskContext/ColumnContext

- [ ] Task 18: Code quality review (AC: 1-10)
  - [ ] Ensure code follows same patterns as TaskContext/ColumnContext
  - [ ] Run linter and fix any issues
  - [ ] Ensure TypeScript strict mode compliance
  - [ ] Review error handling
  - [ ] Review performance optimizations
  - [ ] Verify all acceptance criteria are met

## Dev Notes

### Previous Story Insights
[Source: Story 2.1, Story 2.2, Story 2.4]

**Key Learnings from Story 2.1:**
- TimerContext was created with basic functionality
- TimerService handles timer start/stop operations
- TimerStateRepository manages persistence
- Basic state management is in place

**Key Learnings from Story 2.2:**
- Elapsed time updates every second
- TimerDisplay component uses TimerContext
- Real-time updates are implemented

**Key Learnings from Story 2.4:**
- Service Worker integration for background timer
- Tab visibility detection
- Timer state recovery on app load

**Key Learnings from TaskContext/ColumnContext:**
- Use useMemo for repository instances
- Use useCallback for all functions
- Use useMemo for context value object
- Optimistic updates pattern
- Error handling with error state
- Loading state management

**Important Notes:**
- TimerContext already exists (from Story 2.1)
- Need to refine and optimize based on TaskContext/ColumnContext patterns
- Focus on performance optimization and edge case handling
- Ensure proper integration with existing contexts

### Context Pattern Analysis
[Source: TaskContext.tsx, ColumnContext.tsx, architecture/common/frontend-architecture.md]

**Common Patterns:**
- State structure: `{ data, loading, error }`
- Repository instance: `useMemo(() => new Repository(), [])`
- Functions: `useCallback` with proper dependencies
- Context value: `useMemo` to prevent unnecessary re-renders
- Optimistic updates: Update state immediately, then persist

**TimerContext Should Follow:**
```typescript
// Repository pattern
const repository = useMemo(() => new TimerStateRepository(), []);

// Functions with useCallback
const startTimer = useCallback(async (taskId: string) => {
  // Implementation
}, [repository, /* other deps */]);

// Memoized context value
const value = useMemo(() => ({
  ...state,
  startTimer,
  stopTimer,
  getElapsedTime,
}), [state, startTimer, stopTimer, getElapsedTime]);
```

### Performance Optimization Patterns
[Source: React documentation, architecture/common/coding-standards.md]

**Preventing Unnecessary Re-renders:**
- Use `useMemo` for context value object
- Use `useCallback` for functions passed to context
- Split context if needed (separate state from functions)
- Use `React.memo` on consuming components
- Use selective subscriptions (custom hooks)

**Debouncing/Throttling:**
- Throttle elapsed time updates (every second)
- Debounce rapid operations (start/stop)
- Use `useCallback` with debounced functions
- Clean up timers/intervals properly

**Example Pattern:**
```typescript
// Throttle elapsed time updates
const [elapsedTime, setElapsedTime] = useState(0);

useEffect(() => {
  if (!isActive) return;
  
  const interval = setInterval(() => {
    setElapsedTime(prev => {
      const newTime = calculateElapsedTime();
      return newTime !== prev ? newTime : prev; // Only update if changed
    });
  }, 1000);
  
  return () => clearInterval(interval);
}, [isActive, startTime]);
```

### Context Integration Patterns
[Source: App.tsx, TaskContext.tsx, ColumnContext.tsx]

**Provider Nesting:**
```typescript
<ColumnProvider>
  <TaskProvider>
    <TimerProvider>
      {/* App components */}
    </TimerProvider>
  </TaskProvider>
</ColumnProvider>
```

**Accessing Multiple Contexts:**
- Create custom hooks that combine contexts if needed
- Use useContext in components that need multiple contexts
- Ensure contexts don't create circular dependencies

**Example:**
```typescript
// Custom hook combining contexts
export const useTaskWithTimer = (taskId: string) => {
  const task = useTaskContext().getTaskById(taskId);
  const timer = useTimerContext();
  const isActive = timer.activeTaskId === taskId;
  
  return { task, isActive, elapsedTime: timer.getElapsedTime(taskId) };
};
```

### Edge Case Handling
[Source: architecture/common/error-handling-strategy.md, Epic 2 AC 9]

**Edge Cases to Handle:**
1. **Rapid Start/Stop:** Debounce or queue operations
2. **Browser Refresh:** Recover timer state on mount
3. **Task Deleted:** Handle timer for deleted task gracefully
4. **Invalid State:** Validate and reset corrupted state
5. **IndexedDB Errors:** Handle errors gracefully, don't crash
6. **Multiple Tabs:** Ensure single active timer across tabs (from Story 2.4)

**Implementation Pattern:**
```typescript
const startTimer = useCallback(async (taskId: string) => {
  // Validate task exists
  const task = taskContext.getTaskById(taskId);
  if (!task) {
    throw new Error('Task not found');
  }
  
  // Debounce rapid calls
  if (isStarting) return;
  setIsStarting(true);
  
  try {
    // Stop previous timer if active
    if (activeTaskId) {
      await stopTimer();
    }
    
    // Start new timer
    // ... implementation
  } finally {
    setIsStarting(false);
  }
}, [taskId, activeTaskId, taskContext]);
```

### Testing Patterns
[Source: TaskContext.test.tsx, ColumnContext.test.tsx, architecture/common/testing-strategy.md]

**Context Testing Pattern:**
- Mock repository
- Test state updates
- Test error handling
- Test edge cases
- Test re-render behavior

**Example Test Structure:**
```typescript
describe('TimerContext', () => {
  let mockRepository: jest.Mocked<TimerStateRepository>;
  
  beforeEach(() => {
    mockRepository = createMockRepository();
  });
  
  it('starts timer and updates state', async () => {
    // Test implementation
  });
  
  it('handles rapid start/stop calls', async () => {
    // Test debouncing
  });
  
  it('recovers timer state on mount', async () => {
    // Test recovery logic
  });
});
```

### File Locations
[Source: architecture/unified-project-structure.md, Story 2.1]

**Files to Review/Modify:**
- `src/contexts/TimerContext.tsx` - Refine and optimize
- `src/services/TimerService.ts` - Review integration
- `src/App.tsx` - Ensure proper provider nesting
- `tests/unit/contexts/TimerContext.test.tsx` - Enhance tests

**New Files to Create (if needed):**
- `src/hooks/useTaskWithTimer.ts` - Combined context hook (optional)
- `src/utils/timerStateValidation.ts` - State validation utilities (optional)

### Performance Testing
[Source: architecture/common/coding-standards.md]

**Performance Metrics:**
- Re-render count (React DevTools Profiler)
- Timer update frequency
- IndexedDB write frequency
- Memory usage
- CPU usage

**Optimization Targets:**
- Only affected components re-render on timer updates
- Timer updates don't cause layout shifts
- IndexedDB writes are batched/debounced
- No memory leaks from timers/intervals

### Coding Standards
[Source: architecture/common/coding-standards.md]

**Critical Rules:**
- Type Safety: Always use TypeScript types/interfaces, avoid `any`
- Performance: Use React.memo, useMemo, useCallback appropriately
- Error Handling: All async operations must have try/catch
- Context Patterns: Follow same patterns as TaskContext/ColumnContext
- Testing: Write comprehensive tests for edge cases

**Context-Specific Rules:**
- Always use useMemo for context value
- Always use useCallback for context functions
- Always handle errors gracefully
- Always clean up timers/intervals
- Always validate state

### Project Structure Notes
[Source: architecture/unified-project-structure.md]

**Context Organization:**
- All contexts in `src/contexts/` directory
- Follow same naming and structure patterns
- Use same testing patterns
- Use same documentation patterns

**Integration Points:**
- TimerContext integrates with TaskContext (may need task data)
- TimerContext integrates with ColumnContext (indirectly via TaskContext)
- TimerContext used by TimerControl, TimerDisplay components
- TimerContext used by TimerService

### Testing Requirements
[Source: architecture/common/testing-strategy.md]

**Unit Tests:**
- TimerContext: State management, methods, edge cases
- Integration: TimerContext with TaskContext
- Performance: Re-render behavior
- Error handling: Error scenarios

**Test Organization:**
- Unit tests: `tests/unit/contexts/TimerContext.test.tsx`
- Use Jest + React Testing Library
- Mock repositories and other contexts
- Test with React DevTools Profiler

**Specific Test Requirements:**
- Test state updates trigger re-renders
- Test single active timer enforcement
- Test debouncing/throttling
- Test edge cases (rapid start/stop, browser refresh)
- Test re-render optimization
- Test error handling

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-19 | 1.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA Agent_
