# Story 3.5: Real-Time Revenue Calculation

## Status
Draft

## Story
**As a** user,
**I want** to see real-time revenue potential for my billable tasks,
**so that** I can track my earnings as I work.

## Acceptance Criteria

1. Revenue calculation: billable hours × hourly rate (respecting rate hierarchy)
2. Task card displays revenue potential for that task (if billable and rate is set)
3. Revenue calculation updates in real-time as time is tracked
4. Revenue calculation includes all time entries for a task (not just active timer)
5. Revenue is displayed with currency formatting (e.g., "$1,250.00")
6. Revenue calculation handles missing rates gracefully (shows "Rate not set" or $0.00)
7. Revenue calculation is accurate (no rounding errors in currency display)
8. Revenue updates immediately when rate changes or time is added/edited
9. Revenue calculation is performant (doesn't slow down board rendering)
10. Revenue data is stored/calculated efficiently (cached or computed on demand)

## Tasks / Subtasks

- [ ] Task 1: Implement calculateTaskRevenue in RevenueService (AC: 1, 4, 7)
  - [ ] Update `src/services/RevenueService.ts` (from Story 3.4)
  - [ ] Implement `calculateTaskRevenue(task: Task, timeEntries: TimeEntry[]): number | null`
  - [ ] Calculate total billable hours: Sum all timeEntries durations (in minutes), convert to hours
  - [ ] Get effective hourly rate using getEffectiveHourlyRate() (from Story 3.4)
  - [ ] Calculate revenue: billableHours × effectiveRate
  - [ ] Return null if task is not billable (task.isBillable === false)
  - [ ] Return null if no effective rate is set
  - [ ] Return 0 if billable hours are 0 (even if rate is set)
  - [ ] Ensure accurate decimal calculations (use proper rounding for currency)
  - [ ] Add JSDoc comments explaining calculation logic
  - [ ] Add unit tests for revenue calculation

- [ ] Task 2: Create RevenueDisplay component (AC: 2, 5, 6)
  - [ ] Create `src/components/task/RevenueDisplay.tsx`
  - [ ] Accept props: `revenue: number | null`, `isBillable: boolean`, `showLabel?: boolean`
  - [ ] Display formatted revenue using currencyUtils.formatCurrency() (from Story 3.4)
  - [ ] Handle null revenue gracefully:
    - [ ] If task is not billable: Don't display revenue (or show "N/A")
    - [ ] If task is billable but no rate: Show "Rate not set" or "$0.00"
    - [ ] If revenue is 0: Show "$0.00"
  - [ ] Use consistent styling with Tailwind CSS
  - [ ] Add ARIA labels: `aria-label="Revenue: $1,250.00"` or `aria-label="Rate not set"`
  - [ ] Support both light and dark modes
  - [ ] Make component small and unobtrusive (similar to TimeEstimateDisplay)

- [ ] Task 3: Integrate RevenueDisplay into TaskCard (AC: 2, 5, 6)
  - [ ] Update `src/components/kanban/TaskCard.tsx`
  - [ ] Import RevenueDisplay component and RevenueService
  - [ ] Calculate revenue for task using RevenueService.calculateTaskRevenue()
  - [ ] Load time entries for task (use existing TimeEntryRepository)
  - [ ] Load client/project if needed for rate hierarchy (use ClientContext, ProjectContext)
  - [ ] Render RevenueDisplay component when task is billable
  - [ ] Position revenue display appropriately (near timer display or time estimate)
  - [ ] Ensure revenue display doesn't clutter card layout
  - [ ] Handle loading state while calculating revenue

- [ ] Task 4: Implement real-time revenue updates (AC: 3, 8)
  - [ ] Update TaskCard to recalculate revenue when:
    - [ ] Timer is started/stopped (time entry added)
    - [ ] Time entry is added/edited/deleted (via TimeEntryModal)
    - [ ] Task rate changes (task.hourlyRate updated)
    - [ ] Client/project rate changes (if task assigned to client/project)
    - [ ] Task billable status changes (task.isBillable updated)
  - [ ] Use useEffect hooks to watch for changes
  - [ ] Subscribe to TimerContext updates for timer changes
  - [ ] Subscribe to TaskContext updates for task changes
  - [ ] Subscribe to ClientContext/ProjectContext updates for rate changes
  - [ ] Debounce rapid updates if needed for performance
  - [ ] Ensure updates are immediate (no noticeable delay)

- [ ] Task 5: Optimize revenue calculation performance (AC: 9, 10)
  - [ ] Cache revenue calculations per task (use useMemo in TaskCard)
  - [ ] Only recalculate when dependencies change (task, timeEntries, rates)
  - [ ] Load client/project data efficiently (use Context if available, avoid redundant queries)
  - [ ] Consider lazy loading revenue for tasks not in viewport (if virtual scrolling used)
  - [ ] Ensure calculation doesn't block UI rendering
  - [ ] Use React.memo on RevenueDisplay to prevent unnecessary re-renders
  - [ ] Profile performance with many tasks (1000+ tasks scenario)
  - [ ] Optimize if needed (e.g., batch calculations, web workers for heavy computation)

- [ ] Task 6: Handle active timer in revenue calculation (AC: 3, 4)
  - [ ] Update RevenueService.calculateTaskRevenue() to include active timer time
  - [ ] Get active timer state from TimerContext or TimerStateRepository
  - [ ] If timer is active for task, add elapsed time to total billable hours
  - [ ] Calculate elapsed time: (currentTime - timerStartTime) in minutes
  - [ ] Include active timer time in revenue calculation
  - [ ] Update revenue display in real-time as timer runs (every second or on interval)
  - [ ] Ensure active timer time is included even if no time entries exist yet

- [ ] Task 7: Add revenue calculation to TaskDetailPanel (AC: 2, 5)
  - [ ] Update `src/components/task/TaskDetailPanel.tsx` (if exists) or create it
  - [ ] Display revenue in task detail view
  - [ ] Show breakdown: billable hours × rate = revenue
  - [ ] Show effective rate source (task/project/client/global)
  - [ ] Use RevenueDisplay component for consistent formatting
  - [ ] Update revenue when time entries change in detail panel

- [ ] Task 8: Add unit tests for RevenueService.calculateTaskRevenue (AC: 1, 4, 6, 7)
  - [ ] Create `tests/unit/services/RevenueService.test.ts` (or update existing)
  - [ ] Test revenue calculation with billable task and rate set
  - [ ] Test revenue calculation with non-billable task (should return null)
  - [ ] Test revenue calculation with no rate set (should return null)
  - [ ] Test revenue calculation with multiple time entries
  - [ ] Test revenue calculation includes active timer time
  - [ ] Test revenue calculation with 0 billable hours (should return 0 or null)
  - [ ] Test decimal precision (no rounding errors)
  - [ ] Test rate hierarchy (task > project > client > global)
  - [ ] Test edge cases (null values, missing client/project)

- [ ] Task 9: Add unit tests for RevenueDisplay component (AC: 2, 5, 6)
  - [ ] Create `tests/unit/components/task/RevenueDisplay.test.tsx`
  - [ ] Test rendering with valid revenue (shows formatted currency)
  - [ ] Test rendering with null revenue and billable task (shows "Rate not set")
  - [ ] Test rendering with non-billable task (doesn't show revenue or shows "N/A")
  - [ ] Test rendering with $0.00 revenue
  - [ ] Test ARIA labels are correct
  - [ ] Test currency formatting (uses currencyUtils.formatCurrency)

- [ ] Task 10: Add unit tests for TaskCard revenue integration (AC: 2, 3, 8)
  - [ ] Update `tests/unit/components/kanban/TaskCard.test.tsx`
  - [ ] Test RevenueDisplay renders when task is billable and rate is set
  - [ ] Test RevenueDisplay doesn't render when task is not billable
  - [ ] Test revenue updates when time entry is added
  - [ ] Test revenue updates when task rate changes
  - [ ] Test revenue updates when client/project rate changes
  - [ ] Test revenue includes active timer time
  - [ ] Mock RevenueService, TimeEntryRepository, Contexts appropriately

- [ ] Task 11: Add integration tests for revenue calculation workflow (AC: 1-10)
  - [ ] Create `tests/integration/revenue-calculation.test.tsx`
  - [ ] Test complete workflow: Create billable task → Set rate → Track time → Verify revenue
  - [ ] Test revenue updates in real-time as timer runs
  - [ ] Test revenue includes all time entries (not just active timer)
  - [ ] Test revenue handles missing rates gracefully
  - [ ] Test revenue calculation with rate hierarchy (task > project > client > global)
  - [ ] Test revenue updates when rate changes
  - [ ] Test revenue formatting (currency display)
  - [ ] Use React Testing Library for component integration testing

- [ ] Task 12: Handle edge cases and error scenarios (AC: 6, 7)
  - [ ] Handle task with no time entries (show $0.00 or "No time tracked")
  - [ ] Handle task with billable=false (don't show revenue)
  - [ ] Handle task with no rate set (show "Rate not set")
  - [ ] Handle task with rate but 0 hours (show $0.00)
  - [ ] Handle calculation errors gracefully (show error message or fallback)
  - [ ] Ensure no division by zero errors
  - [ ] Ensure proper rounding for currency (2 decimal places)
  - [ ] Test with very large revenue amounts (formatting)

- [ ] Task 13: Add loading and error states for revenue display (AC: 2, 6)
  - [ ] Show loading indicator while calculating revenue (if async)
  - [ ] Show error state if revenue calculation fails
  - [ ] Handle missing client/project data gracefully
  - [ ] Ensure revenue display doesn't break if contexts are not available
  - [ ] Provide fallback UI for error states

## Dev Notes

### Previous Story Insights

From Story 3.4 (Hourly Rate Configuration), key learnings:
- RevenueService.getEffectiveHourlyRate() exists and implements rate hierarchy
- Currency formatting utilities (currencyUtils) exist
- Rate hierarchy: Task > Project > Client > Global
- RateDisplay component exists for showing rates

**Dependencies:**
- Story 3.4 must be completed (RevenueService.getEffectiveHourlyRate(), currencyUtils)
- Story 3.3: Task.isBillable field exists
- Story 2.x: TimeEntry model and TimeEntryRepository exist
- TimerContext exists for active timer state

### Data Models

**Task Model (relevant fields):**
```typescript
interface Task {
  // ... other fields
  isBillable: boolean;            // Whether task is billable
  hourlyRate: number | null;      // Task-specific hourly rate
  clientId: string | null;        // Reference to client (for rate hierarchy)
  projectId: string | null;       // Reference to project (for rate hierarchy)
  // ... other fields
}
```
[Source: architecture/common/data-models.md#task]

**TimeEntry Model:**
```typescript
interface TimeEntry {
  id: string;
  taskId: string;                // Reference to task
  startTime: Date;
  endTime: Date | null;
  duration: number;               // Duration in minutes
  isManual: boolean;
  // ... other fields
}
```
[Source: architecture/common/data-models.md#timeentry]

**TimerState Model (for active timer):**
```typescript
interface TimerState {
  taskId: string;
  startTime: Date;
  lastUpdateTime: Date;
  status: 'active' | 'paused' | 'stopped';
}
```
[Source: architecture/common/data-models.md#timerstate]

**Revenue Calculation Formula:**
- Total billable hours = Sum of all TimeEntry.duration (in minutes) + active timer elapsed time (in minutes)
- Convert to hours: billableHours = totalMinutes / 60
- Revenue = billableHours × effectiveHourlyRate
- Effective rate from RevenueService.getEffectiveHourlyRate() (Task > Project > Client > Global)

**Database Schema:**
- TimeEntries table: `'id, taskId, startTime, endTime, [taskId+startTime]'` indexes
- TimerState table: `'taskId'` index (unique, only one active timer)
[Source: architecture/common/database-schema.md#dexiejs-schema-definition]

### API Specifications

**RevenueService Methods:**
- `calculateTaskRevenue(task: Task, timeEntries: TimeEntry[], activeTimer?: TimerState): number | null`
  - Calculates revenue for a single task
  - Returns null if task is not billable
  - Returns null if no effective rate is set
  - Returns 0 if billable hours are 0
  - Includes active timer time if provided
  - Uses getEffectiveHourlyRate() for rate hierarchy

**TimeEntryRepository Methods:**
- `getByTaskId(taskId: string): Promise<TimeEntry[]>` - Get all time entries for a task
- `getTotalTimeForTask(taskId: string): Promise<number>` - Get total time in minutes

**TimerStateRepository Methods:**
- `getActive(): Promise<TimerState | null>` - Get active timer state

[Source: architecture/components.md#revenue-calculation-service]

### Component Specifications

**RevenueDisplay Component:**
- Location: `src/components/task/RevenueDisplay.tsx`
- Props: 
  - `revenue: number | null` (calculated revenue)
  - `isBillable: boolean` (whether task is billable)
  - `showLabel?: boolean` (show "Revenue:" label)
- Behavior:
  - Displays formatted revenue using currencyUtils.formatCurrency()
  - Shows "Rate not set" if revenue is null and task is billable
  - Doesn't display if task is not billable
  - Shows "$0.00" if revenue is 0
- Styling: Small, unobtrusive, consistent with TimeEstimateDisplay

**TaskCard Updates:**
- Calculate revenue using RevenueService.calculateTaskRevenue()
- Load time entries for task
- Load client/project for rate hierarchy (if needed)
- Display RevenueDisplay component when task is billable
- Update revenue in real-time when dependencies change

[Source: architecture/common/frontend-architecture.md#component-architecture]

### File Locations

Based on project structure:
- Components: `src/components/task/RevenueDisplay.tsx` (new)
- Services: `src/services/RevenueService.ts` (update from Story 3.4)
- Tests: `tests/unit/components/task/`, `tests/unit/services/`, `tests/integration/`

[Source: architecture/unified-project-structure.md]

### Testing Requirements

**Unit Tests:**
- Service tests: RevenueService.calculateTaskRevenue() (all scenarios)
- Component tests: RevenueDisplay (rendering, formatting, edge cases)
- Component tests: TaskCard revenue integration
- Target: 80%+ code coverage

**Integration Tests:**
- Complete revenue calculation workflow
- Real-time updates (timer, time entries, rate changes)
- Rate hierarchy validation
- Performance testing with many tasks

**Test Organization:**
- Unit tests: `tests/unit/services/`, `tests/unit/components/task/`
- Integration tests: `tests/integration/revenue-calculation.test.tsx`

[Source: architecture/common/testing-strategy.md]

### Technical Constraints

**Coding Standards:**
- Use TypeScript with strict types (no `any`)
- One component per file
- Use Context API for state management (avoid prop drilling)
- Always use repository pattern (never access IndexedDB directly from components)
- All async operations must have try/catch error handling
- Use React.memo, useMemo, useCallback appropriately for performance
- All interactive elements must have ARIA labels and keyboard navigation support

**Error Handling:**
- Handle missing client/project data gracefully
- Handle calculation errors (show error message or fallback)
- Handle missing time entries (show $0.00)
- Ensure no division by zero errors

**Performance:**
- Cache revenue calculations per task (use useMemo)
- Only recalculate when dependencies change
- Debounce rapid updates if needed
- Consider lazy loading for tasks not in viewport
- Profile performance with 1000+ tasks
- Ensure calculation doesn't block UI rendering

**Revenue Calculation Accuracy:**
- Use proper decimal arithmetic (avoid floating point errors)
- Round to 2 decimal places for currency display
- Convert minutes to hours accurately (minutes / 60)
- Include active timer time in calculation
- Sum all time entries correctly

**Real-Time Updates:**
- Subscribe to TimerContext for timer changes
- Subscribe to TaskContext for task changes
- Subscribe to ClientContext/ProjectContext for rate changes
- Update revenue immediately when dependencies change
- Handle rapid updates efficiently (debounce if needed)

[Source: architecture/common/coding-standards.md]

### Project Structure Notes

The project structure already includes:
- `src/services/RevenueService.ts` - RevenueService from Story 3.4 (needs calculateTaskRevenue method)
- `src/utils/currencyUtils.ts` - Currency formatting utilities from Story 3.4
- `src/components/kanban/TaskCard.tsx` - TaskCard component (needs revenue display)
- `src/services/data/repositories/TimeEntryRepository.ts` - TimeEntryRepository with getByTaskId()
- `src/contexts/TimerContext.tsx` - TimerContext for active timer state
- `src/contexts/TaskContext.tsx` - TaskContext for task updates
- `src/contexts/ClientContext.tsx` - ClientContext from Story 3.1 (for rate hierarchy)
- `src/contexts/ProjectContext.tsx` - ProjectContext from Story 3.2 (for rate hierarchy)

New components need to be created:
- `src/components/task/RevenueDisplay.tsx` (new)

[Source: architecture/unified-project-structure.md]

### Additional Considerations

**Revenue Display UX:**
- Show revenue prominently but not obtrusively on task card
- Position near timer display or time estimate for context
- Use consistent styling with other task metadata
- Show loading state while calculating (if async)
- Show error state if calculation fails

**Real-Time Update Frequency:**
- Update revenue when timer runs (every second or on interval)
- Update revenue immediately when time entry is added/edited/deleted
- Update revenue immediately when rate changes
- Consider debouncing if updates are too frequent (but AC 3 requires real-time)

**Active Timer Inclusion:**
- Include active timer elapsed time in revenue calculation
- Update revenue display as timer runs (real-time)
- Calculate elapsed time: (currentTime - timerStartTime) in minutes
- Handle timer pause/resume correctly

**Performance Optimization:**
- Cache revenue calculations per task (use useMemo)
- Only recalculate when dependencies change (task, timeEntries, rates, timer)
- Load client/project data efficiently (use Context, avoid redundant queries)
- Consider virtual scrolling for large task lists (lazy load revenue)
- Profile with 1000+ tasks to ensure performance

**Edge Cases:**
- Task with no time entries: Show $0.00 or "No time tracked"
- Task with billable=false: Don't show revenue
- Task with no rate: Show "Rate not set"
- Task with rate but 0 hours: Show $0.00
- Very large revenue amounts: Ensure formatting works correctly
- Multiple rapid updates: Handle efficiently (debounce if needed)

**Integration with Future Stories:**
- Story 3.6 (Revenue Dashboard) will use RevenueService for dashboard calculations
- Ensure RevenueService methods are reusable for dashboard
- Consider adding calculateClientRevenue() and calculateProjectRevenue() methods (for Story 3.6)

## Testing

### Testing Standards

**Test File Location:**
- Unit tests: `tests/unit/services/`, `tests/unit/components/task/`
- Integration tests: `tests/integration/`

**Testing Frameworks:**
- Jest ^29.7.0 for unit tests
- React Testing Library ^14.0.0 for component tests
- Mock Dexie/IndexedDB for repository tests

**Test Patterns:**
- Use `render`, `screen`, `fireEvent` from React Testing Library
- Mock Context providers when testing components
- Mock IndexedDB operations when testing repositories
- Test user interactions, not implementation details
- Aim for 80%+ code coverage

**Specific Test Requirements:**
- Test revenue calculation with various scenarios (billable/non-billable, rates set/not set)
- Test revenue includes all time entries (not just active timer)
- Test revenue includes active timer time
- Test revenue updates in real-time (timer, time entries, rate changes)
- Test rate hierarchy (task > project > client > global)
- Test currency formatting (various amounts, decimals)
- Test edge cases (null values, 0 hours, missing rates)
- Test performance with many tasks (1000+)
- Test error handling (missing data, calculation errors)

[Source: architecture/common/testing-strategy.md]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-23 | 1.0 | Initial story draft | Scrum Master |

## Dev Agent Record

### Agent Model Used
_TBD - To be filled by Dev Agent_

### Debug Log References
_TBD - To be filled by Dev Agent_

### Completion Notes List
_TBD - To be filled by Dev Agent_

### File List
_TBD - To be filled by Dev Agent_

## QA Results
_TBD - To be filled by QA Agent_
