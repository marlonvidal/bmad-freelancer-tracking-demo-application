# Story 3.6: Revenue Dashboard View

## Status
Draft

## Story
**As a** user,
**I want** to view a revenue dashboard with daily, weekly, and monthly summaries,
**so that** I can understand my earnings trends and billable hour distribution.

## Acceptance Criteria

1. Revenue dashboard is accessible from main navigation/menu
2. Dashboard displays daily revenue summary (today's billable hours × rates)
3. Dashboard displays weekly revenue summary (current week's totals)
4. Dashboard displays monthly revenue summary (current month's totals)
5. Revenue breakdown by client is shown (which clients generated most revenue)
6. Revenue breakdown by project is shown (which projects generated most revenue)
7. Total billable hours are displayed alongside revenue amounts
8. Dashboard data is calculated from IndexedDB time entries and rates
9. Dashboard updates reflect latest time entries and rate changes
10. Dashboard is visually clear with charts or tables showing revenue distribution
11. Dashboard can filter by date range (future enhancement: basic date selection)
12. Dashboard loads efficiently even with large amounts of historical data

## Tasks / Subtasks

- [ ] Task 1: Create date utility functions for date ranges (AC: 2, 3, 4, 11)
  - [ ] Create `src/utils/dateUtils.ts`
  - [ ] Implement `getTodayRange(): { start: Date, end: Date }` - Returns today's date range (00:00:00 to 23:59:59)
  - [ ] Implement `getCurrentWeekRange(): { start: Date, end: Date }` - Returns current week (Sunday to Saturday or Monday to Sunday)
  - [ ] Implement `getCurrentMonthRange(): { start: Date, end: Date }` - Returns current month (first day to last day)
  - [ ] Implement `isDateInRange(date: Date, range: { start: Date, end: Date }): boolean` - Check if date is in range
  - [ ] Handle timezone correctly (use local timezone)
  - [ ] Add unit tests for date range calculations

- [ ] Task 2: Extend RevenueService with aggregate calculation methods (AC: 2, 3, 4, 5, 6, 8)
  - [ ] Update `src/services/RevenueService.ts` (from Story 3.5)
  - [ ] Implement `calculateClientRevenue(clientId: string, dateRange?: { start: Date, end: Date }): Promise<number>`
    - [ ] Get all tasks for client (filter by clientId and isBillable=true)
    - [ ] Get all time entries for those tasks within date range
    - [ ] Calculate revenue for each task using calculateTaskRevenue()
    - [ ] Sum all task revenues
  - [ ] Implement `calculateProjectRevenue(projectId: string, dateRange?: { start: Date, end: Date }): Promise<number>`
    - [ ] Get all tasks for project (filter by projectId and isBillable=true)
    - [ ] Get all time entries for those tasks within date range
    - [ ] Calculate revenue for each task using calculateTaskRevenue()
    - [ ] Sum all task revenues
  - [ ] Implement `calculateTotalRevenue(dateRange?: { start: Date, end: Date }): Promise<number>`
    - [ ] Get all billable tasks
    - [ ] Get all time entries for those tasks within date range
    - [ ] Calculate revenue for each task
    - [ ] Sum all task revenues
  - [ ] Implement `calculateTotalBillableHours(dateRange?: { start: Date, end: Date }): Promise<number>`
    - [ ] Get all billable tasks
    - [ ] Get all time entries for those tasks within date range
    - [ ] Sum all durations (in minutes), convert to hours
  - [ ] Add JSDoc comments explaining each method
  - [ ] Add unit tests for aggregate calculations

- [ ] Task 3: Create revenue breakdown data structures (AC: 5, 6)
  - [ ] Define `ClientRevenueBreakdown` interface: `{ clientId: string, clientName: string, revenue: number, hours: number }`
  - [ ] Define `ProjectRevenueBreakdown` interface: `{ projectId: string, projectName: string, clientId: string, clientName: string, revenue: number, hours: number }`
  - [ ] Implement `getClientRevenueBreakdown(dateRange?: { start: Date, end: Date }): Promise<ClientRevenueBreakdown[]>`
    - [ ] Get all clients
    - [ ] For each client, calculate revenue and hours
    - [ ] Sort by revenue descending
    - [ ] Return array of breakdowns
  - [ ] Implement `getProjectRevenueBreakdown(dateRange?: { start: Date, end: Date }): Promise<ProjectRevenueBreakdown[]>`
    - [ ] Get all projects
    - [ ] For each project, calculate revenue and hours
    - [ ] Sort by revenue descending
    - [ ] Return array of breakdowns

- [ ] Task 4: Create RevenueDashboard component (AC: 1, 2, 3, 4, 7, 10)
  - [ ] Create `src/components/revenue/RevenueDashboard.tsx`
  - [ ] Create main dashboard layout with sections:
    - [ ] Summary cards: Daily, Weekly, Monthly revenue and hours
    - [ ] Client breakdown section
    - [ ] Project breakdown section
  - [ ] Load data on component mount using RevenueService
  - [ ] Display loading states while data loads
  - [ ] Display error states if data load fails
  - [ ] Use Tailwind CSS for styling
  - [ ] Ensure responsive design (mobile-friendly)
  - [ ] Add ARIA labels for accessibility

- [ ] Task 5: Create SummaryCard component for daily/weekly/monthly summaries (AC: 2, 3, 4, 7)
  - [ ] Create `src/components/revenue/SummaryCard.tsx`
  - [ ] Accept props: `title: string`, `revenue: number`, `hours: number`, `loading?: boolean`
  - [ ] Display formatted revenue using currencyUtils.formatCurrency()
  - [ ] Display formatted hours using timeUtils.formatDuration()
  - [ ] Show loading skeleton if loading is true
  - [ ] Use consistent card styling (similar to TaskCard)
  - [ ] Add ARIA labels

- [ ] Task 6: Create RevenueBreakdownTable component (AC: 5, 6, 10)
  - [ ] Create `src/components/revenue/RevenueBreakdownTable.tsx`
  - [ ] Accept props: `breakdown: ClientRevenueBreakdown[] | ProjectRevenueBreakdown[]`, `type: 'client' | 'project'`
  - [ ] Display table with columns: Name, Revenue, Hours, Percentage
  - [ ] Sort by revenue descending (default)
  - [ ] Calculate percentage of total revenue for each row
  - [ ] Format revenue and hours using currencyUtils and timeUtils
  - [ ] Show empty state if no data
  - [ ] Use Tailwind CSS for table styling
  - [ ] Ensure table is responsive (scrollable on mobile)
  - [ ] Add ARIA labels and table headers

- [ ] Task 7: Add navigation to Revenue Dashboard (AC: 1)
  - [ ] Create `src/components/common/Navigation.tsx` (if not exists) or update existing navigation
  - [ ] Add "Revenue Dashboard" link/button to main navigation
  - [ ] Update App.tsx to manage view state (add ViewContext or use existing pattern)
  - [ ] View state: 'board' | 'dashboard' | 'settings'
  - [ ] When "Revenue Dashboard" clicked, set view to 'dashboard'
  - [ ] When logo/home clicked, set view to 'board'
  - [ ] Render RevenueDashboard when view === 'dashboard'
  - [ ] Render KanbanBoard when view === 'board'
  - [ ] Ensure navigation is accessible (keyboard navigation, ARIA labels)

- [ ] Task 8: Implement real-time dashboard updates (AC: 9)
  - [ ] Update RevenueDashboard to subscribe to Context updates:
    - [ ] TaskContext - for task changes (billable status, rate changes)
    - [ ] TimerContext - for timer changes (time entries added)
    - [ ] ClientContext - for client rate changes
    - [ ] ProjectContext - for project rate changes
  - [ ] Recalculate dashboard data when dependencies change
  - [ ] Use useEffect hooks to watch for changes
  - [ ] Debounce rapid updates if needed for performance
  - [ ] Ensure updates are immediate (no noticeable delay)
  - [ ] Show loading indicator during recalculation if needed

- [ ] Task 9: Optimize dashboard performance (AC: 12)
  - [ ] Cache dashboard calculations (use useMemo)
  - [ ] Only recalculate when dependencies change (date range, time entries, rates)
  - [ ] Load data efficiently (batch queries, use indexes)
  - [ ] Consider pagination or limiting results for breakdown tables (top 10 clients/projects)
  - [ ] Use React.memo on breakdown components to prevent unnecessary re-renders
  - [ ] Profile performance with large datasets (1000+ tasks, years of data)
  - [ ] Optimize if needed (e.g., web workers for heavy computation, virtual scrolling for tables)

- [ ] Task 10: Add date range filtering (AC: 11)
  - [ ] Create `src/components/revenue/DateRangeFilter.tsx`
  - [ ] Accept props: `onRangeChange: (range: { start: Date, end: Date }) => void`
  - [ ] Provide preset buttons: Today, This Week, This Month, All Time
  - [ ] Provide custom date range picker (start date, end date inputs)
  - [ ] Default to current period (today/week/month based on view)
  - [ ] Update dashboard data when range changes
  - [ ] Store selected range in component state
  - [ ] Use native date inputs or date picker library
  - [ ] Ensure date inputs are accessible

- [ ] Task 11: Add unit tests for dateUtils (AC: 2, 3, 4)
  - [ ] Create `tests/unit/utils/dateUtils.test.ts`
  - [ ] Test getTodayRange() returns correct range (00:00:00 to 23:59:59)
  - [ ] Test getCurrentWeekRange() returns correct week range
  - [ ] Test getCurrentMonthRange() returns correct month range
  - [ ] Test isDateInRange() correctly identifies dates in/out of range
  - [ ] Test edge cases (month boundaries, year boundaries, leap years)

- [ ] Task 12: Add unit tests for RevenueService aggregate methods (AC: 2, 3, 4, 5, 6, 8)
  - [ ] Update `tests/unit/services/RevenueService.test.ts`
  - [ ] Test calculateClientRevenue() with date range
  - [ ] Test calculateClientRevenue() without date range (all time)
  - [ ] Test calculateProjectRevenue() with date range
  - [ ] Test calculateProjectRevenue() without date range
  - [ ] Test calculateTotalRevenue() with date range
  - [ ] Test calculateTotalRevenue() without date range
  - [ ] Test calculateTotalBillableHours() with date range
  - [ ] Test getClientRevenueBreakdown() returns sorted breakdown
  - [ ] Test getProjectRevenueBreakdown() returns sorted breakdown
  - [ ] Test edge cases (no clients, no projects, no time entries, date ranges)

- [ ] Task 13: Add unit tests for RevenueDashboard component (AC: 1, 2, 3, 4, 7, 10)
  - [ ] Create `tests/unit/components/revenue/RevenueDashboard.test.tsx`
  - [ ] Test dashboard renders summary cards
  - [ ] Test dashboard renders client breakdown table
  - [ ] Test dashboard renders project breakdown table
  - [ ] Test loading states display correctly
  - [ ] Test error states display correctly
  - [ ] Test empty states display correctly
  - [ ] Test dashboard updates when data changes
  - [ ] Mock RevenueService and Contexts appropriately

- [ ] Task 14: Add integration tests for revenue dashboard workflow (AC: 1-12)
  - [ ] Create `tests/integration/revenue-dashboard.test.tsx`
  - [ ] Test navigation to dashboard
  - [ ] Test dashboard displays correct daily/weekly/monthly summaries
  - [ ] Test dashboard displays client/project breakdowns
  - [ ] Test dashboard updates when time entries are added
  - [ ] Test dashboard updates when rates change
  - [ ] Test date range filtering works correctly
  - [ ] Test dashboard loads efficiently with large datasets
  - [ ] Use React Testing Library for component integration testing

- [ ] Task 15: Handle edge cases and empty states (AC: 2, 3, 4, 5, 6)
  - [ ] Handle no time entries: Show $0.00 revenue, 0 hours
  - [ ] Handle no billable tasks: Show $0.00 revenue, 0 hours
  - [ ] Handle no clients/projects: Show empty breakdown tables with message
  - [ ] Handle date ranges with no data: Show $0.00 for that period
  - [ ] Handle missing rates: Exclude from revenue calculation (or show $0.00)
  - [ ] Show helpful empty state messages
  - [ ] Ensure UI doesn't break with edge cases

## Dev Notes

### Previous Story Insights

From Story 3.5 (Real-Time Revenue Calculation), key learnings:
- RevenueService.calculateTaskRevenue() exists and can be reused
- Revenue calculation formula: billableHours × effectiveRate
- Rate hierarchy: Task > Project > Client > Global
- Currency formatting utilities exist (currencyUtils)
- Time formatting utilities exist (timeUtils.formatDuration())

**Dependencies:**
- Story 3.5 must be completed (RevenueService.calculateTaskRevenue())
- Story 3.4: Rate hierarchy and RevenueService.getEffectiveHourlyRate()
- Story 3.3: Task.isBillable field
- Story 3.1, 3.2: Client and Project models

### Data Models

**TimeEntry Model (for date filtering):**
```typescript
interface TimeEntry {
  id: string;
  taskId: string;
  startTime: Date;              // Used for date range filtering
  endTime: Date | null;
  duration: number;             // Duration in minutes
  isManual: boolean;
  // ... other fields
}
```
[Source: architecture/common/data-models.md#timeentry]

**Task Model (relevant fields):**
```typescript
interface Task {
  // ... other fields
  isBillable: boolean;          // Filter for billable tasks only
  hourlyRate: number | null;
  clientId: string | null;
  projectId: string | null;
  // ... other fields
}
```
[Source: architecture/common/data-models.md#task]

**Client Model (for breakdown):**
```typescript
interface Client {
  id: string;
  name: string;
  defaultHourlyRate: number | null;
  // ... other fields
}
```
[Source: architecture/common/data-models.md#client]

**Project Model (for breakdown):**
```typescript
interface Project {
  id: string;
  clientId: string;
  name: string;
  defaultHourlyRate: number | null;
  // ... other fields
}
```
[Source: architecture/common/data-models.md#project]

**Date Range Interface:**
```typescript
interface DateRange {
  start: Date;  // Inclusive start date (00:00:00)
  end: Date;     // Inclusive end date (23:59:59)
}
```

**Breakdown Interfaces:**
```typescript
interface ClientRevenueBreakdown {
  clientId: string;
  clientName: string;
  revenue: number;
  hours: number;  // Total billable hours
}

interface ProjectRevenueBreakdown {
  projectId: string;
  projectName: string;
  clientId: string;
  clientName: string;
  revenue: number;
  hours: number;  // Total billable hours
}
```

**Database Schema:**
- TimeEntries table has `startTime` index for date range queries
- Compound index `[taskId+startTime]` enables efficient task + date queries
[Source: architecture/common/database-schema.md#dexiejs-schema-definition]

### API Specifications

**RevenueService Methods (new):**
- `calculateClientRevenue(clientId: string, dateRange?: DateRange): Promise<number>`
  - Calculates total revenue for a client within date range
  - Filters by billable tasks and time entries in range
- `calculateProjectRevenue(projectId: string, dateRange?: DateRange): Promise<number>`
  - Calculates total revenue for a project within date range
- `calculateTotalRevenue(dateRange?: DateRange): Promise<number>`
  - Calculates total revenue across all clients/projects
- `calculateTotalBillableHours(dateRange?: DateRange): Promise<number>`
  - Calculates total billable hours (in hours, not minutes)
- `getClientRevenueBreakdown(dateRange?: DateRange): Promise<ClientRevenueBreakdown[]>`
  - Returns revenue breakdown by client, sorted by revenue descending
- `getProjectRevenueBreakdown(dateRange?: DateRange): Promise<ProjectRevenueBreakdown[]>`
  - Returns revenue breakdown by project, sorted by revenue descending

**TimeEntryRepository Methods:**
- `getByTaskId(taskId: string): Promise<TimeEntry[]>` - Get all time entries for a task
- Query by date range: `db.timeEntries.where('startTime').between(start, end).toArray()`

[Source: architecture/components.md#revenue-calculation-service]

### Component Specifications

**RevenueDashboard Component:**
- Location: `src/components/revenue/RevenueDashboard.tsx`
- Layout:
  - Summary cards row (Daily, Weekly, Monthly)
  - Client breakdown section (table)
  - Project breakdown section (table)
  - Date range filter (top of dashboard)
- Behavior:
  - Loads data on mount
  - Updates when dependencies change
  - Shows loading/error states
  - Responsive design

**SummaryCard Component:**
- Location: `src/components/revenue/SummaryCard.tsx`
- Props: `title: string`, `revenue: number`, `hours: number`, `loading?: boolean`
- Displays formatted revenue and hours
- Card-style layout

**RevenueBreakdownTable Component:**
- Location: `src/components/revenue/RevenueBreakdownTable.tsx`
- Props: `breakdown: ClientRevenueBreakdown[] | ProjectRevenueBreakdown[]`, `type: 'client' | 'project'`
- Table with columns: Name, Revenue, Hours, Percentage
- Sortable by revenue (default descending)

**DateRangeFilter Component:**
- Location: `src/components/revenue/DateRangeFilter.tsx`
- Props: `onRangeChange: (range: DateRange) => void`
- Preset buttons: Today, This Week, This Month, All Time
- Custom date range inputs

[Source: architecture/common/frontend-architecture.md#component-architecture]

### File Locations

Based on project structure:
- Components: `src/components/revenue/` (new directory)
- Utilities: `src/utils/dateUtils.ts` (new)
- Services: `src/services/RevenueService.ts` (update from Story 3.5)
- Navigation: `src/components/common/Navigation.tsx` (new or update)
- Tests: `tests/unit/utils/`, `tests/unit/services/`, `tests/unit/components/revenue/`, `tests/integration/`

[Source: architecture/unified-project-structure.md]

### Testing Requirements

**Unit Tests:**
- Utility tests: dateUtils (date range calculations)
- Service tests: RevenueService aggregate methods (all scenarios)
- Component tests: RevenueDashboard, SummaryCard, RevenueBreakdownTable, DateRangeFilter
- Target: 80%+ code coverage

**Integration Tests:**
- Complete dashboard workflow
- Navigation to dashboard
- Data loading and display
- Real-time updates
- Date range filtering

**Test Organization:**
- Unit tests: `tests/unit/utils/`, `tests/unit/services/`, `tests/unit/components/revenue/`
- Integration tests: `tests/integration/revenue-dashboard.test.tsx`

[Source: architecture/common/testing-strategy.md]

### Technical Constraints

**Coding Standards:**
- Use TypeScript with strict types (no `any`)
- One component per file
- Use Context API for state management (avoid prop drilling)
- Always use repository pattern (never access IndexedDB directly from components)
- All async operations must have try/catch error handling
- Use React.memo, useMemo, useCallback appropriately for performance
- All interactive elements must have ARIA labels and keyboard navigation support

**Error Handling:**
- Handle missing data gracefully (show empty states)
- Handle calculation errors (show error message)
- Handle date range errors (invalid dates, end before start)
- Show loading states during data fetch

**Performance:**
- Cache dashboard calculations (use useMemo)
- Only recalculate when dependencies change
- Load data efficiently (use indexes, batch queries)
- Consider limiting breakdown results (top 10 clients/projects)
- Profile performance with large datasets
- Optimize if needed (web workers, virtual scrolling)

**Date Handling:**
- Use local timezone for date ranges
- Handle timezone correctly (start of day 00:00:00, end of day 23:59:59)
- Handle month/year boundaries correctly
- Handle week boundaries correctly (Sunday-Saturday or Monday-Sunday)

**Navigation:**
- Single-page application (no routing)
- View state managed through Context: 'board' | 'dashboard' | 'settings'
- Navigation bar with links to switch views
- Logo/home button returns to board view

[Source: architecture/common/coding-standards.md]

### Project Structure Notes

The project structure already includes:
- `src/services/RevenueService.ts` - RevenueService from Story 3.5 (needs aggregate methods)
- `src/utils/currencyUtils.ts` - Currency formatting utilities from Story 3.4
- `src/utils/timeUtils.ts` - Time formatting utilities
- `src/App.tsx` - App component (needs view state management)
- `src/contexts/TaskContext.tsx`, `ClientContext.tsx`, `ProjectContext.tsx` - For real-time updates

New components need to be created:
- `src/components/revenue/` directory (new)
- `src/components/revenue/RevenueDashboard.tsx` (new)
- `src/components/revenue/SummaryCard.tsx` (new)
- `src/components/revenue/RevenueBreakdownTable.tsx` (new)
- `src/components/revenue/DateRangeFilter.tsx` (new)
- `src/components/common/Navigation.tsx` (new or update)
- `src/utils/dateUtils.ts` (new)

[Source: architecture/unified-project-structure.md]

### Additional Considerations

**Dashboard Layout:**
- Summary cards at top (Daily, Weekly, Monthly)
- Client breakdown table below summaries
- Project breakdown table below client breakdown
- Date range filter at top (above summaries)
- Responsive: Stack vertically on mobile, side-by-side on desktop

**Visual Design:**
- Use consistent card styling (similar to TaskCard)
- Use tables for breakdowns (clear, scannable)
- Show percentages for breakdown (visual indicator of distribution)
- Use color coding if helpful (e.g., green for revenue)
- Ensure charts/tables are accessible (ARIA labels, keyboard navigation)

**Date Range Filtering:**
- Preset buttons: Today, This Week, This Month, All Time
- Custom range: Start date and end date inputs
- Default to current period based on view
- Update dashboard immediately when range changes
- Store selected range in component state

**Performance Optimization:**
- Cache calculations per date range
- Only recalculate when date range or data changes
- Consider pagination for breakdown tables (top 10, show more button)
- Load data efficiently (use IndexedDB indexes)
- Profile with large datasets (1000+ tasks, years of data)

**Real-Time Updates:**
- Subscribe to TaskContext, TimerContext, ClientContext, ProjectContext
- Recalculate dashboard when dependencies change
- Debounce rapid updates if needed
- Show loading indicator during recalculation

**Empty States:**
- No time entries: Show $0.00, 0 hours, helpful message
- No billable tasks: Show $0.00, 0 hours
- No clients/projects: Show empty table with message
- Date range with no data: Show $0.00 for that period

**Future Enhancements:**
- Charts/graphs for revenue trends (future enhancement)
- Export dashboard data (CSV/JSON) - may be in Export epic
- Comparison periods (this month vs last month) - future enhancement
- Advanced filtering (by client, project, task) - future enhancement

## Testing

### Testing Standards

**Test File Location:**
- Unit tests: `tests/unit/utils/`, `tests/unit/services/`, `tests/unit/components/revenue/`
- Integration tests: `tests/integration/`

**Testing Frameworks:**
- Jest ^29.7.0 for unit tests
- React Testing Library ^14.0.0 for component tests
- Mock Dexie/IndexedDB for repository tests

**Test Patterns:**
- Use `render`, `screen`, `fireEvent` from React Testing Library
- Mock Context providers when testing components
- Mock IndexedDB operations when testing services
- Test user interactions, not implementation details
- Aim for 80%+ code coverage

**Specific Test Requirements:**
- Test date range calculations (today, week, month)
- Test aggregate revenue calculations (client, project, total)
- Test breakdown sorting and formatting
- Test dashboard navigation
- Test real-time updates
- Test date range filtering
- Test empty states
- Test performance with large datasets
- Test error handling

[Source: architecture/common/testing-strategy.md]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-23 | 1.0 | Initial story draft | Scrum Master |

## Dev Agent Record

### Agent Model Used
_TBD - To be filled by Dev Agent_

### Debug Log References
_TBD - To be filled by Dev Agent_

### Completion Notes List
_TBD - To be filled by Dev Agent_

### File List
_TBD - To be filled by Dev Agent_

## QA Results
_TBD - To be filled by QA Agent_
